[동적 및 가변 저장장치]
1. cv::Mat 클래스
Mat 클래스는 임의의 차원으로 구성된 밀집 배열을 나타내는 데 사용한다.
여기서 밀집이란 요소 값이 0이더라도 메모리에 데이터값이 존재한다는 뜻이다.
밀집 형식을 피하기 위한 대안으로 희소 배열(cv::SparseMat)이 있다. 0이 아닌 항목만 저장한다.
대부분 배열 요소가 0 값을 갖는 경우 희소 배열 사용시 메모리를 크게 절약하는 효과를 볼 수 있지만 밀집 배열을 사용하면 메모리가 낭비된다. 희소배열의 대표적인 예로 히스토그램이 있다.

Mat 클래스는 다차원의 배열을 저장할 수 있다. '래스터 주사 순서'에 따라 n차원의 배열에 데이터를 순차적으로 저장한다.
배열의 내용을 알려주는 flags, 차원의 수를 나타내는 dims, 행과 열의 수를 나타내는 rows/cols (단 dims >2인 경우 유효하지 않음), 배열의 데이터를 가리키는 data 포인터, Ptr<>의 참조 카운터와 유사한 refcount 멤버 변수를 포함한다.
refcount는 Mat의 변수 data가 나타내는 데이터 포인터를 스마트 포인터처럼 관리할 수 있게 해준다.
data의 메모리 레이아웃은 stop[] 배열로 나타낸다.

Mat에 저장된 데이터가 단순 기본 타입일 필요는 없다. 각 데이터 요소는 단일 또는 다중 숫자가 될 수 있다.
다중 숫자인 경우, 라이브러리는 그것을 다중 채널 배열로 인식한다.

Mat 타입의 변수를 인스턴스화 하는 것만으로 배열을 생성할 수 있다.
이 방법으로 만든 배열은 크기와 데이터 타입이 없지만, create()같은 멤버 함수를 사용해 동적으로 데이터를 할당할 수 있다.
CV_{8U, 16S, 16U, 32S, 32F, 64F}C{1, 2, 3}의 형식을 갖는다. 예를 들어 CV_32FC3은 32비트 부동 소수점 3채널 배열을 의미한다.

Mat은 기본 생성자 외의 생성자는 다음과 같은 세 가지 기본 범주로 나뉜다.
1) 행의 수와 열의 수를 사용해 2차원 배열을 만드는 경우
2) 2차원 배열을 만들기 위해 cv::Size 객체를 사용하는 경우
3) 차원의 수와 각 차원의 크기를 정수 형태로 지정해 n차원 배열을 만드는 경우
이 중 일부는 cv::Scalar로 배열 전체의 초기 값을 설정하거나 배열의 포인터를 직접 전달해 데이터 포인터를 초기화 할 수 있다. 배열의 포인터를 전달한 경우, 이미 존재하는 데이터 포인터에 대한 헤더 정보만 변경한다. (즉 데이터는 복사되지 않고 data 파라미터로 전달된 데이터를 가리킨다.)

Mat의 복사 생성자는 이미 존재하는 배열에서 또 다른 배열을 생성한다.
기존 배열의 부분 영역에서 다른 배열을 만드는 메서드 세 개와 행렬 표현식의 결과에서 새로운 행렬을 초기화하는 생성자 하나가 있다.
부분 영역(관심 영역) 생성자는 세 가지 유형으로 나뉜다.
1) 행과 열의 범위를 지정하는 방법 (2차원 행렬에서만 작동)
2) cv::Rect를 사용해 직사각형의 부분 영역을 지정하는 방법 (2차원 행렬에서만 작동)
3) Range 객체를 사용하는 방법 (포인터 아규먼트 ranges에 포함된 요소의 수와 배열 mat의 차원 수가 같아야 한다.)
즉, Mat이 2보다 큰 ndim을 가진 다차원 배열이면 반드시 세 번째 방법을 사용해야 한다.

기존 C 스타일의 CvMat이나 IplImage 구조체를 C++ Mat으로 바꾸고 싶다면 두 가지 방법이 있다.
1) copyData 파라미터 = false, 이미 존재하는 데이터를 그대로 사용하고 헤더만 변경하는 방법
2) copyData 파라미터 = true, 기존 데이터의 값을 복사해 새로운 데이터를 생성하는 방법 (새로운 메모리를 할당하고 이전 데이터의 값을 복사한다.)

Mat 배열의 개별 요소에 접근하는 데에는 여러 방법이 있다.
직접 접근하는 기본 방법은 at<> (템플릿) 멤버 함수를 사용하는 것이다.이는 다양한 차원을 지원하기 위해 서로 다른 아규먼트를 갖는 다수의 변형된 함수로 구성된다.
at<> 함수의 사용 방법은 접근하는 행렬의 데이터 타입으로 템플릿을 특수화하고 원하는 행과 열을 지정해 해당 요소에 접근하는 것이다.

행렬 생성자는 실행 시 결정되는 데이터 타입을 컴파일 시간에 알아내려 할 때 DataType<> 템플릿을 사용한다.
2차원 배열의 특정 행을 Mat의 ptr<> 템플릿 멤버 함수로 수행한다. (각 행의 데이터는 연속적이라 가능하지만, 배열의 특정 열의 데이터에 접근하는 것은 비연속적이므로 불가능하다.)
ptr<>() 함수는 포인터를 얻고자 하는 행을 정수 아규먼트로 지정한다. ptr<>() 함수는 배열을 구성하는 기본 타입에 대한 포인터를 반환한다. 예를들어 배열의 타입이 CV34FC3이면 반환값은 float* 타입이다.
그러므로 float 타입의 3채널 행렬 mtx가 있을 때 mtx.ptr<Vec3f>(3)은 mtx의 3번째 행에 있는 첫 번째 요소의 첫 번째 (부동 소수점) 채널에 대한 포인터 타입을 반환한다.

배열의 모든 항목에 접근하려면 한 번에 한 행씩 접근해야한다.
배열의 행들이 (메모리 상에서) 연속적으로 패킹 되지 않을 수 있기 때문이다. 그러나 is Continuous() 멤버 함수로 연속 패킹 여부를 확인할 수 있다. 연속된 패킹이라면 첫 번째 행의 첫 번째 요소에 대한 포인터를 거대한 1차원 배열의 포인터로 생각하고 배열 전체의 요소에 접근할 수 있다.
다른 순차 접근 방식은 Mat에 내장된 반복자를 사용하는 것이다. non-const 템플릿 반복자인 cv::MatIterator<>와 const 템플릿 반복자인 cv::MatConstIterator<> 타입이 있다. Mat의 begin()과 end() 멤버 함수가 이 타입의 반복자 객체를 반환한다. 이 반복 메서드들은 배열의 연속 패킹 여부를 자동으로 처리할 뿐만 아니라 여러 차원을 가진 배열도 잘 처리한다.
각 반복자는 배여을 구성하는 객체의 타입으로 선언돼야 한다.
반복자 접근법은 두 배열을 더하거나 RGB 색상 공간에서 HSW 색상 공간으로 배열을 변환하는 경우를 모든 위치에서 동일한 연산을 정확하게 수행한다.

[다차원 배열 반복자: NAryMatIterator]
반복자 cv::MatIterator<> 처럼 패킹된 배열의 불연속성을 처리하지는 못하지만 많은 배열을 한 번에 접근하는 반복자가 있다. 이 반복자는 cv:NArayMatIterator이며, 이때 반복되는 배열은 동일 구조여야 한다.
배열을 반복하는 단일 요소를 반환하는 대신 다차원 배열 반복자는 평면이라는 배열의 블록을 반환한다.
평면은 입력 배열의 일부(1차원 or 2차원 단면)로 데이터가 메모리에서 연속되게 보장해 불연속성 문제를 해결한다. 즉, 연속적인 메모리가 하나씩 주어진다. 이는 각 평면에 대해 배열 연산이나 반복 연산을 내부의 불연속성에 대해 신경쓰지 않고 반복해서 연산을 수행할 수 있다.
평면의 개념은 여러 배열을 동시에 반복하는 개념과 완전히 별개의 개념이다.
(ex_4-1, 4-2)

[블록 단위로 배열 요소 접근]
* cv::Mat의 블록 단위 메모리 접근 멤버 함수
m.row(i), 행렬 m의 행 i에 해당하는 배열
m.col(i), 행렬 m의 열 i에 해당하는 배열
m.rowRange(i, j), 행렬 m의 행i~j에 해당하는 배열
m.rowRange(cv::Range(i, j)), 행렬 m의 행i~j에 해당하는 배열
m.colRange(i, j), 행렬 m의 열i~j에 해당하는 배열
m.colRange(cv::Range(i, j)), 행렬 m의 열i~j에 해당하는 배열
m.diag(d), 행렬 m의 d오프셋 대각선에 해당하는 배열
m(cv::Range(i0, i1), cv::Range(j0, j1)), 행렬 m의 직사각형의 왼쪽 위(i0, j0)과 반대쪽 모서리의 좌표((i1)-1, (j1)-1)영역에 해당하는 배열
m(cv::Rect(i, j, w, h)), 행렬 m의 직사각형의 왼쪽 위(i, j)와 반대쪽 모서리의 좌표(i+w-1, j+h-1) 영역에 해당하는 배열
m(ranges), 행렬 m에서 ranges[0]-ranges[ndim-1] 범위에 해당하는 하위 영역에 해당하는 배열

m2 = m.row(3)와 같이 코드를 작성하면 m의 3행의 데이터에 접근하기 위해 m2 배열의 헤더를 생성하고 m의 data 포인터와 step 배열 등을 가리키게 한다. 때문에 m2 데이터 수정 시, m의 데이터도 수정된다.
이러한 점을 보완하기 위해 copyTo() 멤버 함수로 데이터만 복사할 수도 있다.
이를 토대로 기존 배열에 접근하기 위해 새 배열을 만드는 시간이 적게 드는 것과 기존 배열과 새 별의 크기가 서로 독립적이라는 특징이 있다.
rowRange()와 colRange()는 여러개의 연속된 행이나 열을 배열 형태로 추출한다는 점만 제외하면 기능적으로 row()와 col()과 같다.
diag() 멤버 함수는 반환된 배열이 행렬의 대각선 요소를 참조한다는 점을 제외하면 row()나 col()과 동일,
전달인자가 0이면 주 대각선(0,0에서 시작하는 대각선)을 반환한다. 양수 값이면 배열의 위쪽으로 주 대각선에서 오프셋(이동)되고 음수 값이면 배열의 아래쪽으로 주 대각선에서 오프셋된다.

[행렬 표현식(Ex. m2 = m0 + m1), 대수학과 cv::Mat]
* 행렬 표현식에 사용 가능한 연산
m0 + m1 / m0 - m1, 행렬의 덧셈/뺼셈
m0 + s / m0 - s / s + m0 / s - m1, 행렬과 싱글톤 사이의 덧셈/뺄셈
-m0, 행렬의 음수화
s * m0 / m0 * s, 싱글톤으로 행렬의 스케일 조정
m0.mul(m1) / m0/m1, m0와 m1간의 요소별 곱셈/나눗셈
m0 * m1, m0와 m1의 행렬 곱셈 (mul = 요소곱(shape 그대로), * = 행렬곱(shape 달라질 수도 있음))
m0.inv(method), 역행렬(method 기본값 = DECOMP_LU)
m0.t(), m0의 전치 행렬(복사 X)
m0 > m1 / m0 >= m1 / m0 == m1, 요소별 비교(0 or 255인 uchar 행렬 반환)
m0 & m1 / m0 | m1 / m0 ^ m1 / -m0 / m0 & s / m0 | s / m0 ^ s, 행렬들 또는 행렬과 싱글톤 사이의 비트 논리 연산자
min(m0, m1) / max(m0, m1) / min(m0, s) / max(m0, s), 두 행렬 또는 행렬과 싱글톤 사이의 요소 최대값/최소값
cv::abs(m0), m0의 요소 절대값
m0.cross(m1) / m0.dot(m1), 벡터의 외적(3x1 행렬에 대해서만 정의됨)/내적
cv::Mat::eye, zeros, ones(Nr, Nc, type), 타입 type과 Nr*Nc 크기 행렬을 초기화하는 정적 멤버 함수

m2 = m0 + m1에서 결과를 저장하기 위해 임시 배열을 만들어야 한다. m2가 임시 배열을 참조하게 되고 연산자(operator+())가 끝나면 임시 배열에 대한 참조는 사라지지만 *참조 횟수가 0이 아니기에 m2가 해당 배열을 참조할 수 있게 된다. 이는 opencv 배열 클래스의 여러 중요한 연산이 내부적으로 표현식 연산을 사용하도록 설계되어 필요에 따라 자동으로 생성되고 데이터 영역이 할당된다. 데이터 영역이 더 이상 필요하지 않으면 백그라운드에서 동적으로 헤제되고 계산 결과는 목적지에 저장되는 특성 때문이다.
* 참조, 메모리의 다른 위치에 있는 개체의 주소를 저장하는 것이며 포인터와 달리 초기화되고 나면 다른 개체를 참조하도록 설정하거나 null로 설정할 수 없다.

역행렬 연산자인 inv()는 행렬 역변환을 하기 위해 다양한 알고리즘을 사용한다.
1. cv::DECOMP_LU, LU 분해를 의미하며 모든 가역 행렬에 적용된다.
2. cv::DECOMP_CHOLESKY, 숄레스키 분해로 역변환된다. 이 분해는 대칭적으로 양의 정부호 행렬에만 작동하지만 행렬이 큰 경우 LU 분해보다 수행 속도가 훨씬 빠르다.
3. cv::DECOMP_SVD, 특이값 분해로써 역변환을 수행한다. 오직 특이 행렬 또는 비정방 행렬(이 경우 의사 역행렬로 계산된다.)인 경우에만 작동한다.

외에도 행렬을 행렬과 스칼라로 변환하는 cv::norm(), mean(), sum()같은 함수가 있다.

[포화 캐스팅]
opencv에서 변수가 오버플로우나 언더플로우 될 위험이 있는 연산이 자주 수행되는데, 특히 부호가 없는 타입에 대해 뺄셈을 포함한 다양한 연산을 수행할 때 자주 발생한다. 이러한 위험을 포화 캐스팅을 사용해 해결한다. 즉, opencv에서는 산술 연산과 배열 연산에 일어날 수 있는 언더/오버플로우를 자동으로 감지한다는 뜻이다. 발생할 경우 라이브러리 함수는 계산 결과를 가장 낮은 값이나 높은 값으로 설정한다.
직접 함수를 구현할 수도 있지만, opencv가 쉽게 사용할 수 있게 캐스팅 연산자를 템플릿 형태로 제공한다. cv::saturate_cast<>()라는 템플릿 함수가 구현돼 있으며, 이 함수를 사용하기 위해 캐스팅 하려는 타입을 템플릿 전달인자로 지정하면 된다.
Ex. uchar& vxy = m0.at<uchar>(y, x); vxy = cv::saturate_cast<uchar>((vxy-128)*2 + 128);
예제에서 8비트 배열 m0 요소를 vxy에 참조시키고 배열 요소 값에서 128을 빼고 2를 곱한(크기 ↑) 다음 128을 더한다 만약 vxy가 10이면 결과가 -108이 되는데 부호 없느 문자의 최소값보다 낮으므로 자동으로 0으로 포화 캐스트된다.

[배열로 할 수 있는 더 많은 것]
* cv::Mat의 나머지 멤버 함수
m1 = m0.clone(), m0의 모든 데이터 요소를 복사해 사본 m1을 만든다.
m0.copyTo(m1), m0의 내용을 m1에 복사하고, 필요한 경우 m1을 재할당한다.(m1 = m0.clone()과 동일)
m0.copyTo(m1, mask), 배열 mask에 표시된 부분만 복사한다는 점을 제외하면 m0.copyTo(m1)과 동일하다.
m0.convertTo(m1, type, scale(기본값 = 1.0), offset(기본값 = 0.0)), 크기를 조정한 수 m0 요소의 타입을 type으로 변환해 m1에 복사한다.
m0.assignTo(m1, type), m0에 m1을 대입한다(convertTo와 유사)
m0.setTo(s, mask), m0의 모든 요소 값을 싱글톤 s로 설정한다. 0이 아닌 mask 요소에 대응하는 m0의 요소값을 변경한다.
m0.reshape(chan, rows), 2차원 행렬의 모양을 변경한다. chan이나 row가 0이면 변화없음을 뜻한다. 데이터는 복사되지 않는다.
m0.push_back(s), m*1행렬을 확장하고 끝에 싱글톤 s의 ㄱ밧을 넣는다.
m0.push_back(m1), m*n을 k행 만큼 더 확장하고 m1(크기 = k*n)의 행렬을 확된된 행에 복사한다.
m0.pop_back(n(기본값 = 1)), m*n의 끝에서 n개의 행을 제거한다.
m0.locateROI(size, offset), cv::Szie size로 m0의 전체 크기를 설정하고 m0가 큰 행렬의 뷰이면 Points& offset을 모서리 시작점으로 설정한다.
m0.adjustROI(t, b, l, r), 뷰의 크기 위로 t, 아래로 b, 왼쪽으로 l, 오른쪽으로 r픽셀만큼 증가시킨다.
m0.total(), 배열 요소의 총수를 계산한다.(채널 포함 X)
m0.isContinuous(), m0의 행이 메모리에 연속적인지 확인한다(true / false)
m0.elemSize(), m0 요소의 크기를 바이트 단위로 반환한다.
m0.elemSize1(), m0의 하위 요소의 크기를 바이트 반위로 반환한다.
m0.type(), m0의 유효한 요소의 타입 식별자를 반환(Ex. CV_32FC3)
m0.depth(), m0의 유요한 개별 채널의 타입 식별자를 반환(Ex. CV_32F)
m0.channels(), m0 요소의 채널 수를 반환한다.
m0.size(), m0의 크기를 cv::Size 객체로 반환.
m0.empty(), 배열에 요소가 없으면(0 또는 NULL) true 아니면 false

[cv::SparseMat, 희소 배열]
cv::SparseMat 배열은 0값 요소가 많을 때 사용하는 클래스다. 희소 행렬은 히스토그램과 같이 고차원 행렬을 사용해 데이터를 표현하고자 할 때 대부분의 공간이 실제로 비어 있을 수 있기 때문에 희소 배열이 사용된다. 사용하는 경우 실제 존재하는 데이터만 사용하여 메모리를 아낄 수 있다.
하지만 밀집 배열 데이터를 희소 행렬에 저장하면 메모리를 너무 많이 사용하고 행렬의 요소별 계산이 밀집 배열보다 더 느리다는 문제가 있다.
많은 연산이 필요 없고, 실제 연산이 전체 계산 속도를 크게 떨어트리지 않는다면 희소 행렬을 사용해 메모리를 경제적으로 사용할 수 있다.
cv::Mat과 비슷하게 동일 연산, 동일 타입을 지원하지만 데이터 저장 방식은 매우 다르다. cv::Mat은 데이터가 순차적으로 패킹되고 주소를 요소의 인덱스로 직접 계산할 수 있지만, cv::SparseMat은 해시 테이블(요소의 수가 많아지면 효율적으로 조회하기 위해 자동으로 커짐)을 사용해 0이 아닌 요소만 저장한다.

희소 배열(SparseMat)과 밀집 배열(Mat)의 큰 차이점은 요소에 접근하는 방법이다.
희소 배열은 cv::SparseMat::ptr(), ref(), value(), find()라는 4개의 접근 함수를 제공한다.

이 중 cv::SparseMat::ptr()에는 몇 가지 변형이 있는데, 그 중 가장 간단한 형태는 다음과 같다.
uchar* cv::SparseMat::ptr(int i, bool createMissing, size_t* hashval=0)
이 함수는 1차원 배열에 접근할 때 사용한다. 
i는 찾고있는 요소의 인덱스이다.
createMissing은 요소가 배열에 없는 경우 해당 요소를 만들어야 할지 결정한다. 기본적으로 cv::SparseMat::ptr() 호출 시, 해당 요소가 배열에 있으면 요소의 포인터를 반환하고 없으면 NULL을 반환하지만 createMissing 파라미터가 true면 해당 요소를 만들고 그 포인터를 반환한다.
hashval은 해시 테이블에서 객체를 검색하면 먼저 해시 키(인덱스)를 계산하고 그와 관련된 목록을 검색하는 두 단계가 필요한데, 보통 키와 관련된 목록이 짧아서 연산 대부분 해시 키를 계산하는 데 사용된다. 만약 이 키 값이 있다면 cv::SparseMat::hash()처럼, 계산에 드는 시간을 아낄 수 있다. hashval이 NULL인 경우 해시 키를 계산하지만, 키가 주어지는 경우 해당 키를 사용한다.
cv::SparseMat::ptr()에서 정수 배열의 포인터 형태를 가진 함수를 사용할 경우에는 접근하려는 배열의 차원과 동일한 요소 개수가 있어야 한다. 또한 부호 없는 문자 타입의 포인터(uchar*)를 반환해서 보통 배열 타입으로의 캐스팅 작업을 필요로 한다.

cv::SparseMat::ref<>(), 접근 템플릿 함수는 배열의 특정 요소를 참조 형태로 반환하기 위해 사용한다.
cv::SparseMat::ptr()과 똑같이 1,2 또는 3개의 요소와 배열의 포인터를 사용하는 형태이고 해시 테이블 조회에 사용할 수 있는 해시값의 포인터를 넣어줄 수도 있다. 템플릿으로 구현되어 있기에 참조하는 배열의 타입을 지정해야한다.
Ex. a_sparse_mat.ref<float>(i, j) += 1.0f;

cv::SparseMat::value<>(), 템플릿 함수는 cv::SparseMat::ref<>()와 형태는 동일하지만, 참조가 아닌 값을 반환한다. 그래서 const 함수로 구현되어 있다.

마지막으로 cv::SparseMat::find<>() 접근자 함수는 cv::SparseMat::ref(), value()와 유사하게 동작하지만, 찾고 있는 객체에 대한 포인터를 반환한다. 템플릿 전달인자에 타입을 넣어 인스턴스화 되므로 cv::SparseMat::ptr()과 달리 반환값을 올바른 타입으로 캐스팅할 필요가 없다. 때문에 cv::SparseMat::ptr()보다 find()를 더 많이 사용한다. 하지만 const 함수로 구현돼 있어 const 포인터를 반환하기에 cv::SparseMat::ptr() 함수와 모든 경우에 대해 바꿔 사용할 수는 없다.

이 외에도 반복자를 통해 희소 행렬의 요소에 접근할 수 있는데 이는 밀집 배열처럼 템플릿으로 구현되어있다.
반복자로는 cv::SparseMatiterator_<>(), cv::SparseMatConstIterator_<>() 함수와 그 대응 함수인 cv::SparseMat::begin<>(), cv::SparseMat::end<>()가 있다. (const 형태의 반복자는 begin(), end()의 반환형이 const 형태이다.) 또한 템플릿 형태가 아닌 cv::SparseMat::begin(), cv::SparseMat::end() 그리고 cv::SparseMatIterator(), cv::SparseMatConstIterator() 함수도 있다.
(ex_4-3)

[희소 배열에 있는 고유한 함수들]
* cv::SparseMat의 추가 클래스 멤버 함수
cv::SparseMat sm, 초기화되지 않은 희소 행렬 생성
cv::SparseMat sm(3, sz, CV_32F), 주어진 배열 sz이용해 float 타입의 3차원 희소 행렬 행성
cv::SparseMat sm(sm0), 기존의 희소 행렬 sm0를 복사해 새 희소 행렬 생성
cv::SparseMat(m0, try1d), 기존의 밀집 행렬 m0에서 희소 행렬을 생성한다. try1d가 true인 경우 n*1 또는 1*n형태를 가진 밀집 행렬이면 m0를 1차원 희소 행렬로 변환하여 생성한다.

cv::SparseMat(&old_sparse_mat), 2.1 이전 버전의 CvSparseMat을 새 희소 행렬로 변환
CvSparseMat* old_sm = (cv::SparseMat*) sm, 2.1 이전 버전 C 스타일의 희소 행렬 포인터를 만든다.이 때 데이터를 전부 복사해 CvSparseMat 객체 만들고 객체 포인터를 반환

size_t n = sm.nzcount(), sm에 있는 0이 아닌 요소 수를 반환한다.
size_t h = sm.hash(i0) / size_t h = sm.hash(i0, i1) / size_t h = sm.hash(i0, i1, i2) / size_t h = sm.hash(idx), 전달된 인자에 따라 해당되는 요소의 해시값을 반환한다. 전달되는 인자의 수는 차원 수와 같아야 하며 n 차원인 경우 idx는 정수 배열의 포인터이며 배열의 개수는 차워의 요소만큼 있어야 한다.

sm.ref<float>(i0) / sm.ref<float>(i0, i1) / sm.ref<float>(i0, i1, i2) / sm.ref<float>(idx), 전달된 인자값에 해당되는 배열의 요소에 값을 대입한다. 전달 인자의 수는 차원 수와 같아야 하며 n 차원인 경우 idx는 정수 배열의 포인터이며 배열 개수는 차원의 요소만큼 있어야 한다.

f0 = sm.value<float>(i0) / f0 = sm.value<float>(i0, i1) / f0 = sm.value<float>(i0, i1, i2) / f0 = sm.value<float>(idx), 전달된 인자 값에 해당되는 요소에 값을 대입힌다. 인자의 수는 차원 수와 같아야 하며 n 차원인 경우 정수 배열 idx의 포인터를 사용하며, 이때 차원 수만큼 배열 요소가 있어야 한다.

p0 = sm.find<float>(i0) / p0 = sm.find<float>(i0, i1) / p0 = sm.find<float>(i0, i1, i2) / p0 = sm.find<float>(idx), 전달된 인자 값에 해당되는 요소의 주소 값을 반환한다. 전달 인자의 수는 차원 수와 같아야하며 n 차원인 경우 정수 배열 idx의 포인터를 사용하며, 이때 차원 수만큼 배열 요소가 있어야 한다.

sm.erase(i0, i1, &hashval) / sm.erase(i0, i1, i2, &hashval) / sm.erase(idx, &hashval), 전달된 인자 값에 해당되는 요소를 제거한다. 전달 인자 값의 수는 차원 수와 같아야 하며 n 차원인 경우 정수 배열 idx의 포인터를 사용하며, 이때 차원만큼 배열의 요소가 있어야 한다. 또한 hashval이 NULL이 아닌 경우 키를 계산하지 않고 제공된 키를 사용한다.

cv::SparseMatIterator<float> it = sm.begin<float>(), 희소 행렬의 반복자 it를 만들어 그것이 부동 소수점 배열 sm의 첫 번째 값(의 포인터)를 가리키게 초기화 한다.
cv::SparseMatIterator<float> it_end = sm.end<float>(), 희소 행렬의 반복자 it_end를 만들어 sm의 마지막 배열 요소(의 포인터)를 가리키게 초기화 한다.

[대형 배열 타입의 템플릿 구조]
cv::Point_<int>를 사용하고자 할 때, cv::Point2i는 cv::Point_<int>에 대한 단순한 별칭(typedef)에 불과하다. 하지만 cv::Mat과 cv::Mat_<>은 이렇게 단순하지 않다.
cv::Mat은 생성자에 기본 타입을 명시적으로 지정해서 타입에 구애받지 않는다. 하지만 cv::Mat_<>의 경우, cv::Mat 클래스를 상속해 사실상 클래스를 특수화한 것이다. 즉, 기존 템플릿 클래스의 멤버 함수를 사용하기 더 편해졌다.

cv::Mat_<>과 cv::SparseMat_<> 템플릿 클래스를 사용하면 템플릿 멤버 함수를 사용할 필요가 없다.
cv::Mat m(10, 10, CV_32FC2) 이 행렬의 각 요소에 접근하기 위해서는
 m.at<Vec2f>(i0, i1) = cv::Vec2f(x, y) 와 같이 행렬의 타입을 지정해야 한다.

템플릿 클래스를 사용해 m을 정의한 경우, 멤버 함수를 특수화하지 않고도 at()이나 operator() 함수를 사용할 수 있다.
cv::Mat_<Vec2f> m(10, 10); m.at(i0, i1) = cv::Vec2f(x, y); m(i0, i1) = cv::Vec2f(x, y)

템플릿 형식을 사용하면 특정 타입의 배열에서만 작동하는 템플릿 함수를 만들 수 있다.
cv::SparseMat_<float>처럼 명시적으로 타입을 지정하는 것 보다 템플릿 함수를 만드는 게 좋다. 또한 반복자의 타입이 명시적으로 float 타입이 되면 printf가 아닌 std::cout 으로 바꾸는 게 좋다.
(ex_4-4)

[요약]
cv::Mat은 opencv에서 행렬, 이미지, 다차원 배열을 나타내는 데 사용된다.
cv::Mat 클래스는 기본 타입과 숫자, 벡터를 지원하고 이미지를 지원하기 위해 Vec3b와 같은 고정 길이 벡터를 가질 수 있도록 설계된 클래스이다.