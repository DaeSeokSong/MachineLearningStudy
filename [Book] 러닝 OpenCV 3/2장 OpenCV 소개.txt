[Include 파일]
	메인 헤더 파일은 opencv2/opencv.hpp
	컴파일 시간을 빨리하기 위해선 필요한 모듈만 include 한다.

	영상 데이터는 1차원이고 BGR 순서로 나열되어있다.

	* opencv.hpp 내부 모듈
		* 오래된 C 데이터 구조 및 산술 루틴,		"opencv2/core/core_c.h"
		* 새로운 C++ 데이터 구조 및 산술 루틴,		"opencv2/core/core.hpp"
		* 대략적인 이웃 매칭 함수, 				"opencv2/flann/miniflann.hpp"
		* 오래된 C 이미지 처리 함수,				"opencv2/imgproc/imgproc_c.h"
		* 새로운 C++ 이미지 처리 함수,			"opencv2/imgproc/imgproc.hpp"
		* 사진 처리 및 복원과 관련된 알고리즘,		"opencv2/video/photo.hpp"
		* 비디오 트래킹 및 백그라운드 분할 루틴,	"opencv2/video/video.hpp"
		* 2차원 피처 트래킹 지원,					"opencv2/features2d/features2d.hpp"
		* 캐스케이드 얼굴 검출기 / latent SVM / HoG / 평면 패치 검출기,	"opencv2/objdetect/objdetect.hpp"
		* 캘리브레이션 및 스테레오,				"opencv2/calib3d/calib3d.hpp"
		* 머신러닝(클러스터링, 패턴 인식),			"opencv2/ml/ml.hpp"
		* 오래된 C 이미지 출력 / 슬라이더 / 마우스 상호 작용 / I/O, "opencv2/highgui/highgui_c.h"
		* 새로운 C++ 이미지 출력 / 슬라이더 / 버튼 / 마우스 / I/O, "opencv2/highgui/highgui.hpp"
		* 사용자 제공 코드(피부 검출, 퍼지 평균 이동 추적, 스핀 이미지, 자체 유사 피처),
		"opencv2/contrib/contrib.hpp" >> 별도의 opencv_contrib 다운 필요

	* namespace cv
		* imread("파일경로", -1), 파일 이름을 기반으로 로드할 파일 포맷을 결정 후 이미지 데이터 구조에 필요한 메모리를 자동으로 할당 / -1을 옵션으로 주면 없을 시 오류 메세지 전달
		* namedWindow("윈도우 이름", 윈도우 사이즈), 화면에 이미지를 표시할 수 있는 윈도우를 연다.
		* destroyWindow("윈도우 이름"), 윈도우를 닫고 관련된 모든 메모리 사용을 해제
		* waitKey(), 키 입력이 있을 때까지 멈추고 기다릴 것을 요청한다. 양수가 전달인자로 넘어가면 밀리 초 단위의 시간 동안 기다린 후 계속 실행 / 음수나 0이 전달인자로 넘어가면 키 입력이 있을 때까지 무한 대기
		* Mat 구조체, 모든 종류의 이미지(단일 채널, 다중 채널, 정수 값, 부동 소수점 값 등)을 처리

	opencv로 비디오를 재생할 때 문제는 각 프레임을 순차적으로 읽는 일종의 루프를 만드는 것이다.
	여기서 VideoCapture 객체는 ffmpeg을 지원하므로 여러 타입의 비디오 파일을 열거나 닫을 수 있다.
	해당 캡쳐 객체에 open()함수를 이용해 열고자 하는 파일의 경로를 문자열로 제공, 파일이 열리면 해당 객체에 상태 정보와 비디오 파일에 대한 모든 정보가 담긴다.
	또한 비디오의 시작점으로 재생 위치를 초기화 시키고 이를 Mat 객체로 인스턴스(VideoCapture >> Mat)화 한다. (ch2/ex_2-3)

	슬라이더 트랙 바는 cv 네임 스페이스의 createTrackbar("라벨(이름)", "넣을 윈도우명", 바인딩될 변수(위치 상태)와 트랙 바의 최댓값(비디오의 총 프레임 수), 콜백 함수(원치 않으면 NULL)) 함수를 호출한 뒤 표시할 윈도우를 지정하면 된다. 비디오의 위치를 재배치할 수 있으며 이를 위해선 콜백이 필요하다. (ch2/ex_2-4)

	* VideoCapture
		디스크나 카메라에 저장된 파일에 대해 동일하게 작동하므로 저장된 비디오를 읽는 방법과 유사함

		디스크에 저장되어 있으면 경로와 파일명을 입력, 카메라의 경우 ID 번호(시스템에 하나만 연결된 경우 0)를 지정한다. 기본값은 -1이고 이는 아무거나 카메라를 고르는 방법으로 카메라가 하나일 때 잘 작동한다.

		* CAP_PROP_POS_FRAMES 속성 = 프레임 단위로 읽는 위치를 설정하고 싶다.
		* .open(0) = 첫번째 카메라를 연다
		* .open(숫자) = 지정한 ID의 카메라를 연다
		* .open(이미지 경로) = 해당 이미지를 연다

	* VideoWriter(카메라 ID, 코덱 종류(매크로), fps, 이미지 크기)
		비디오 스트림에서 한 번에 하나씩 프레임을 캡처하는 캡처 장치처럼 프레임을 하나씩 비디오 파일에 배치하게 해주는 기록 장치

		각 프레임을 VideoWriter 객체로 스트리밍하고 최종적으로 VideoWriter.release() 메서드를 호출하여 마무리한다.

		MJPG 동영상 코덱을 사용하면 CV_FOURCC() 매크로를 두번째 인자로 넣고 해당 매크로 안에 필요에 맞는 문자 4개를 전달해준다.

[필터]
	GaussianBlur(가우시안 블러) 같은 필터의 사이즈는 영역의 중심 픽셀에서 계산되므로 항상 홀수여야 한다 또한 필터 내에 임시 저장소가 있기 때문에 첫번째 전달인자(입력)과 두번째 전달인자(출력)이 같아도 된다.
		* 외에도 blur(), medianBlur(), bilateralFilter()를 사용할 수 있다

	컨볼루션 연산은 공간 영역 필터링을 위한 핵심 연산 방법
	공간 영역 필터링은 연산 대상 픽셀과 그 주변 픽셀들을 활용하여 새로운 픽셀 값을 얻는 방법

	* 블러링 기법,
	블러링(bluring)이란 마치 초점이 맞지 않은 사진처럼 영상을 부드럽게 만드는 필터링 기법이다. 스무딩(smoothing)이라고도 한다.

	* 스케일 공간, 장면이나 물체가 관찰되는 스케일 변화를 처리하기 위해 컴퓨터 비전에서 일반적으로 사용하는 것

	* pyrDown(입력, 출력) 함수, 다운 샘플링(이미지 크기 ↓)
	* cvtColor(입력, 출력, 플래그) 함수, 플래그에 따라 입력이미지를 다르게 변환
	* Canny(입력, 출력, 최소 한계점, 최대 한계점, 커널 크기, 기울기 구하는 법), 윤곽선 따기
	https://webnautes.tistory.com/687
	* at(행(x), 열(y))<데이터형 Ex. Vec3B, uchar(unsigned char) 등>,
	영상 및 이미지의 좌표에 맞는 픽셀 값에 접근
