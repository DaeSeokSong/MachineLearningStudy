[8. 영상 압축]
[8.1 기초]
데이터 압축이란 용어는 주어진 정보량을 표현하는 데 필요한 데이터량을 줄이는 프로세스를 나타낸다.
데이터와 정보는 같은 것이 아니다. 데이터는 정보가 운반되는 수단이다.
같은 양의 정보를 표현하기 위해서 다양한 양의 데이터가 사용될 수 있기에, 무의미하거나 반복된 정보를 포함 하는 것을 여분 데이터를 포함한다고 말한다.
b개와 b'개의 비트에 의한 표현의 각각의 상대적 데이터 여분 R은 R = 1 - 1/C이며, C는 압축률이고 C = b/b'이다.
C = 10이라면 더 큰 표현은 더 작은 표현의 데이터의 매 1 비트에 대해 10개의 데이터 비트를 가진다.
더 큰 표현의 상대적 데이터 여분은 0.9R이며, 그 데이터의 90%가 여분이라는 것이다.
b는 통상적으로 영상을 밝기값들의 2-D 배열로 표현하는 데 필요한 비트 수이다.
2차원 밝기 배열에는 확인 및 활용 가능한 세 가지 주요 데이터 여분 유형이 있다.
1. 코딩 중복성, 코드는 정보체 또는 이벤트 집합을 표현하기 위해 사용되는 기호 체계이다. 각 정보 또는 이벤트 요소에는 코드 단어로 불리는 코드 기호들의 시퀀스가 할당된다. 각 코드 단어에 있는 기호들의 수가 그 길이이다.
2. 공간 및 시간 중복성, 대부분의 2-D 밝기 배열의 화소들이 공간적으로 상관성을 갖기 때문에 이웃과 비슷하거나 종속적이다. 상관성이 있는 화소들을 표현할 때 정보가 불필요하게 복제된다.
비디오 시퀀스에서는 시간적으로 상관성이 있는 화소들도 정보를 복제한다.
3. 무의미한 정보, 대부분의 2-D 밝기 배열들은 인간의 시각 체계에 의해 무시되거나, 영상의 계획된 사용 목적과는 무관한 정보를 포함한다. 사용되지 않는 다는 면에서 해당 정보는 여분이 된다.
[8.1.1 코딩 중복성]
다양한 밝기 값들에 할당되는 코드 단어의 평균 길이는 각각의 밝기를 표현하는 데 사용되는 비트 수와 그 밝기가 발생하는 확률들의 곱을 합해서 구해진다.
M*N 영상을 표현하는데 필요한 총 비트 수는 M*N*L_avg이다. 여기서 자연 m-비트 고정-길이 코드라면 L_avg = m이 된다. L_avg는 영상의 밝기 표현을 위한 이산 랜덤 변수 r_k가 발생할 확률, p_r(r_k)의 합이다. 단위는 bit이다.
코딩 중복성은 이벤트 집합(Ex. 밝기 값)에 할당된 코드가 이벤트의 확률을 최대로 활용하지 않을 때 존재한다.
코딩 중복성은 영상의 밝기들이 자연 이진 코드를 사용해서 표현될 때 대부분 항상 존재한다.
대부분의 영상들이 규칙적이고 어느 정도 예측 가능한 형태와 반사를 갖는 객체들로 구성되며, 묘사될 객체들은 화소보다 훨씬 더 크게 샘플링되기 때문이다.
이의 결과로 대부분의 영상들에서 어떤 밝기들은 다른 것들보다 더 확률이 높다. 그렇기에 대부분의 영상의 히스토그램이 균등하지 않다.
자연 이진 인코딩은 확률이 가장 높은 값과 가장 낮은 값에 똑같이 비트수를 할당하므로, 코딩 중복성을 갖게된다.
[8.1.2 공간 및 시간 중복성]
컴퓨터로 생성된 일정한 밝기의 선 집합에 대한 2-D 밝기 배열에서
1. 256개의 모든 밝기들의 확률이 같다. 이는 영상의 히스토그램이 균등하다는 뜻이다.
2. 각 선의 밝기가 랜덤하게 선택되었기 때문에, 화소들은 수직 방향으로 서로 독립적이다.
3. 각 선 상의 화소들은 같기 때문에, 수평 방향에서는 서로 최대로 연관(완전 종속)되어 있다.
항목 1은 기존 8-비트 밝기 배열로 표현될 때는 가변 길이 코딩으로는 압축될 수 없다는 것을 알려준다.
히스토그램이 균등하지 않았던 영상과는 달리, 고징 길이 8-비트 코드가 이 경우에는 L_avg를 최소화한다.
항목 2, 3은 연속-길이쌍의 시퀀스로 영상을 표현하여 제거될 수 있는 중요한 공간 중복성을 알려준다.
각 연속-길이 쌍은 새로운 밝기 및 그 밝기를 갖는 계속되는 화소 수를 지정한다.
연속-길이 기반 표현은 원래의 2-D, 8비트 밝기 배열을 128:1로 압축한다.
각 256 화소선들이 연속-길이 표현에서 하나의 8비트 밝기 값과 길이 값 256으로 대체된다.
대부분의 화소 밝기들이 이웃들로부터 예측될 수 있으므로, 단일 화소에 의해 운반되는 정보는 적다.
화소가 그의 이웃들로부터 추정될 수 있다는 점에서 화소들의 시각적 기여의 많은 부분이 중복적이다.
공간 및 시간적으로 상관성을 갖는 화소들과 관련된 중복성을 줄이려면, 2-D 배열이 더 효율적이지만, 대개 비시각적인 표현으로 변환되어야 한다.
연속-길이나 인접 화소 간의 차이가 이용될 수 있는데, 이러한 변환을 매핑이라 한다.
원래의 2-D 밝기 배열의 화소들이 변환된 데이터 집합으로부터 오차 없이 복구될 수 있으면 매핑이 가역적이라고 하고, 아니면 비가역적이라 한다.
[8.1.3 무의미한 정보]
데이터를 압축하는 가장 간단한 방법 중 하나는 그 집합으로부터 꼭 필요하지 않은 데이터를 제거하는 것이다.
인간 시작 체계에 의해 무시되거나 의도된 영상 용도와 무관한 정보는 명백한 제거 대상이다.
압축할 떄 해당 정보들을 제거하더라도 복구된 영상의 화질 저하는 거의 인지 되지 않는다.
영상을 히스토그램 평활화하면 밝기 변화를 보일 수 있으며, 감지되지 않았던 일정한 밝기의 영역을 드러낼 수 있다.
영상이 평균값으로만 표현되면 해당 비가시적 구조(상수 밝기 영역들)와 그들을 둘러싸는 랜덤 밝기 변화들(실제 정보)이 손실된다.
이러한 데이터 생략이 정량적 정보의 손실로 이어지므로 보통 양자화라고 부른다.
일반적으로 넓은 입력 값 범위를 제한된 수의 출력 값들로 매핑하는 것을 의미하며, 정보가 손실되므로 비가역 연산이다.
[8.1.4 영상 정보 측정]
정보 손실 없이 한 영상을 묘사하기에 충분한 최소 데이터량에 대해 정보 이론이 수학적인 틀을 제공한다.
기본 전제는 직관과 일치하는 방식으로 측정될 수 있는 확률적 프로세스로서 정보 생성이 모델링될 수 있다는 것이다.
확률 P(E)의 랜덤 이벤트 E가 I(E)의 정보 단위를 가진다고 말한다. P(E) = 1이면 I(E) = 0이고, 아무런 정보가 없다.
I(E)의 밑수가 2면 정보 단위가 비트가 되고 여기서 P(E)가 1/2이면 1비트가 된다. 즉 1 비트는 발생 가능성이 똑같은 두 개의 가능한 이벤트들 중 하나가 발생할 때 전달되는 정보량이다.
각 확률을 가진 이벤트들의 이산 집합의 통계적으로 독립적인 랜덤 이벤트들의 소스가 주어졌을 때, 엔트로피라 불리는 소스 출력당 평균 정보는 H로 표기한다.
각 이산 집합들을 소스 기호라고 부르고, 이들이 통계적으로 독립적이므로 소스 자체는 제로-메모리 소스라고 부른다.
영상을 가상의 제로-메모리 밝기 소스의 출력으로 본다면 관찰된 영상의 히스토그램을 이용해서 소스의 기호 확률들을 추정할 수 있다.
가상 소스(샘플 영상)의 밝기 값들을 (밝기 소스 엔트로피 / 화소) 아래로 코딩하는 것은 불가능하다.
	<Shannon의 제1정리>
	노이즈 없는 코딩 정리로도 불리는 Shannon의 제1정리는 단일 코드 단어(소스 기호당 한 코드 단어가 아닌) n개의 연속적 소스 기호들의 그룹들을 표현하는 것을 고찰하였다. L_avg, n은 n개의 기호 그룹 모두를 표현하는 데 필요한 평균 코드 기호 수이다. n-기호 블록들을 만드는 가상 소스로서 제로-메모리 소스의 n차 확장을 정의하였다.
n개의 소스 기호들의 블록은 n개의 인접 화소들의 그룹에 해당한다. n-화소 블록들에 대한 가변 길이 코드를 구성하기 위해서는 블록들의 상대적 빈도가 계산되어야 한다.
하지만 256개의 밝기 값을 갖는 밝기 소스의 n차 확장은 256^n개의 가능한 n-화소 블록들을 가진다.
따라서 작은 n값에 대해서도, 계산 복잡성이 실제에서의 확장 코딩 방식의 유용성을 제한한다.
상관적 화소들의 블록은 공식으로 예측하는 것보다 더 적은 평균 비트/화소로 코딩될 수 있다.
소스 확장을 이용하기 보다는 덜 상관된 묘사자(밝기 연속-길이)들이 보통 선택되어 확장 없이 코딩된다.
정보 소스의 출력이 유한한 수의 앞선 출력들에 종속될 때, Markov 또는 유한 메모리 소스라고 부른다.
[8.1.5 충실도 기준]
무의미한 시각적 정보의 제거에는 실제 또는 정량적 영상 정보의 손실이 따른다.
정보가 손실되므로, 손실의 성질을 재는 수단이 필요하다. 여기에는 객관적/주관적 충실도 기준이 있다.
정보 손실이 압축 프로세스의 입력 및 출력의 수학적 함수로 표현될 수 있다면, 객관적 충실도 기준에 기반한다고 말한다.
대표적인 예시로 두 영상 간의 rms(root-mean-square) 오차가 있다. rmn 오차가 크면 화질 저하가 심하고, 눈에 띄는 왜곡을 갖는다.
객관적 충실도 기준이 정보 손실을 평가하기 위한 간단하고 편리한 방법을 제공하는 반면, 압축해체된 영상은 궁극적으로 사람에 의해 관찰된다.
따라서 사람의 주관적 평가에 의해 화질을 측정하는 것이 흔히 더 적절하다.
압축해체된 영상을 다양한 관찰자들에게 보여주고, 그들의 평가를 평균화하는 것이다. 평가는 주관적 충실도 기준에 기반한다.
rms 오차가 작더라도 실제로는 데이터 손실이 부분적으로 많이 일어나서 쓰지 못할 만큼의 영상이 될 수 있기에 객관적 충실도 기준만에는 한계가 존재한다.
[8.1.6 영상 압축 모델]
영상 압축 시스템은 인코더와 디코더의 기능 구성으로 이루어진다.
인코더는 압축을 실행하고 디코더는 압축해제라는 반대 연산을 수행한다. 두 연산은 SW 또는 하드웨어와 펌웨어의 조합으로 수행될 수 있다.
코덱(codec)은 인코딩와 디코딩을 동시에 할 수 있는 장치나 프로그램이다.
입력 영상이 인코더에 입력되어 압축된 형태가 생성된다. 이런 형태는 후에 사용을 위해서 저장되거나, 원격 사용과 저장을 위해서 전송된다.
압축 형태가 반대의 디코더에 제시될 때 복구된 출력 영상이 생성된다. 이 때 출력이 입력의 정확한 복사본이 된다면, 해당 압축 시스템은 무오차, 무손실, 정보 보전적이라 부른다.
그 반대의 경우는, 복구된 출력 영상이 왜곡되고 그 압축 시스템은 손실성이라 부른다.
	<인코딩 또는 압축 과정>
	인코더는 일련의 세 가지 독립된 연산을 통해 중복을 제거하도록 설계된다.
	첫 단계에서, 매퍼(mapper)라는 입력 영상을 공간 및 시간적 여분을 감소하도록 설계된 포맷으로 변환한다. 이러한 작용은 일반적으로 가역적이며, 영상을 표현하는데 요구되는 데이터 양을 직접 감소시킬 수 있거나 못할 수도 있다.
	연속-길이 인코딩은 인코딩 과정의 첫 번째 단계에서 압축을 일으키는 매핑의 한 예이다.
	영상을 덜 상관적인 변환 계수(압축을 위해 다 처리되어야 한다.)들의 집합으로 매핑하는 것은 반대되는 경우의 예이다.
	비디오 응용에서는 시간적 중복성 제거를 위해 이전 비디오 프레임(또는 미래)을 매퍼가 사용한다.
	양자화기는 미리 설정된 충실도 기준에 맞춰서 매퍼 출력의 정밀도를 낮춘다.
	목적은 압축된 표현에 무의미한 정보가 들어가지 않게하는 것이다. 이 연산은 비가역적이다. 그러므로 무오차 압축이 요구될 때는 생략되어야 한다.
	비디오 응용에서 미리 결정된 평균 출력 속도가 유지되도록 인코딩된 출력의 비트 속도(비트/초)가 측정되고, 양자화기의 연산을 조정하는 데 사용된다.
	따라서 출력의 시각 품질은 영상의 내용 함수로 프레임마다 변할 수 있다.
	인코딩의 세 번째와 마지막에서 기호 인코더는 양자화기 출력을 표현하기 위한 고정 또는 가변 길이 코드가 사용된다.
	가장 짧은 코드 단어가 가장 자주 발생하는 양자화기 출력 값에 할당되어 코딩 중복성은 최소화한다. 이 연산은 가역적이며, 세 가지 여분성이 각각 제거되도록 처리된다.
	<디코딩 또는 압축해제 과정>
	디코더는 두 가지 구성요소인 기호 디코더와 역 매퍼만을 포함한다.
	인코더의 기호 인코더와 매퍼의 역 순서로 역 연산을 수행한다. 양자화는 정보 손실을 초래하므로, 일반적 디코더 모델에 역 양자화기가 포함되지 않는다.
	비디오 응용에서 디코딩된 출력 프레임들은 내부 프레임 저장소에 유지되어 인코더에서 제거되었던 시간 여분성을 재삽입하는 데 사용된다.
[8.1.7 영상 포맷, 컨테이너, 압축 표준]
영상 파일 포맷은 영상 데이터를 체계화하고 저장하는 표준 방법이다. 이것은 데이터를 정리하는 방법과, 있다면 사용할 압축 유형도 정의한다.
영상 컨테이너는 파일 포맷과 유사하나 다종의 영상 데이터를 취급한다. 반면에 영상 압축 표준은 영상 압축과 해제의 절차를 정의한다.
즉, 영상을 표현하는 데 필요한 데이터의 양을 감소하는 절차를 정의한다.

[8.2 기본적 압축 방법들]
[8.2.1 Huffman 코딩]
코딩 여분성을 제거하기 위한 가장 많이 쓰이는 기법 중 하나는 Huffman이다.
정보 소스의 기호들을 개별적으로 코딩할 때, Huffman 코딩은 소스 기호당 코드 기호 수를 가장 적게 산출할 수 있다.
Shannon의 제 1정리 이론에 의해, 소스 기호가 한 번에 하나씩 코딩된다는 조건 하에서 고정 값 n에 대한 산출 코드는 최적이다.
실제로, 소스 기호는 영상의 밝기이거나 밝기 매핑 연산(화소 차이, 연속 길이 등)의 출력이 된다.
Huffman 접근법의 첫 번째는 고려 대상 기호들의 확률을 정렬하고 가장 낮은 확률 기호들을 다음 소스 축소에서 대신할 단일 기호로 결합하여 일련의 소스 축소를 일으킨다.
대표적인 예시로 이진 코딩이 있다. 두 개의 기호를 갖는 축소된 소스에 도달할 때까지 두 소스를 합쳐 복합 기호를 형성하는 방법이다.
두 번째 단계는 가장 작은 소스로 시작해서 원래의 소스로 되돌아가며 작업을 하면서 각 축소된 소스를 코딩하는 것이다.
두 기호 소스로서 최소 길이 이진 코드는 물론 기호 0과 1이다.
Huffman 과정은 기호들이 한 번에 하나씩 코딩된다는 조건 하에 기호와 확률의 집합에 대해서 최적의 코드를 창출한다.
코드가 생성된 다음, 코딩과 무오차 디코딩은 간단한 룩업 테이블 방식으로 행해진다.
코드 자체는 즉시 유일하게 디코딩 가능한 블록 코드이다. 블록 코드라 불리는 이유는 각 소스 기호가 고정된 코드 기호 시퀀스로 매핑되기 때문이다.
즉시적인 이유는 코드 기호 문자열 안의 각 코드 단어를 디코딩할 때 뒤따르는 기호들을 확인할 필요가 없기 때문이다.
유일하게 디코딩 가능하단 이유는 어따한 코드 기호 문자열로도 단 한 가지 방법으로만 디코딩될 수 있기 때문이다.
따라서 Huffman 인코딩된 기호들의 어떠한 문자열도 문자열의 개개의 기호들을 왼쪽에서 오른쪽으로 검사해가면서 디코딩될 수 있다.
JPEG, MPEG 표준을 포함하는 몇 개의 압축 표준들은 실험 데이터를 근거로 미리 계산된 디폴트 Huffman 코딩 테이블을 갖추고 있다.
[8.2.2 Golomb 코딩]
지수적으로 감소하는 확률 분포를 갖는 음이 아닌 정수 입력들에 대한 코딩을 고찰한다.
이러한 종류의 입력들은 Huffman 코드보다 계산 상으로 더 간단한 코드의 집합을 사용하여 최적으로 인코딩될 수 있다.
음이 아닌 연속 길이 표현을 위해서 제안되었다.
Golomb 코드를 생성하기 위해 필요한 나눗셈들은 이 쉬프트 연산들이 되고, 이 계산상으로 더 간단한 코드를 Golomb-Rice 또는 Rice-코드라고 부른다.
Golomb 코드가 단지 음이 아닌 정수를 표현하는 데 사용될 수 있다는 것과 선택할 수 있는 Golomb 코드가 많이 있다는 것을 기억한다면, 효과적인 응용의 핵심 단계는 제수(나눗셈에서 어떤 수를 나누는 수)를 선택하는 것이다.
영상의 밝기 확률(히스토그램)이 식으로 계산된 확률과 일치할 가능성이 없기 때문에, Golomb 코드는 밝기 코딩에 거의 사용되지 않는다.
그러나 밝기의 차이가 코딩될 때에는 차이 값의 확률이 종종 식과 비슷하여 사용될 수 있다.
Golomb 코딩에서 음의 차이를 취급하기 위해, 매핑이 일반적으로 사용된다.
매핑된 정수는 적절한 Golomb-Rice 코드를 사용해서 효율적으로 인코딩될 수 있다.
Golomb 코드는 길거나 짧은 연속들이 효율적으로 인코딩되게 때문에 연속-길이 인코딩에 유용하다.
Huffman 코드와 같이, Golomb 코드가 가변 길이이고 즉각적으로 유일하게 디코딩할 수 있는 블록 코드이다.
[8.2.3 산술 코딩]
가변-길이 코드(Huffman, Golomb)와는 달리, 산술 코딩은 비블록 코드를 생성한다.
소스 기호와 코드 단어 사이에 1:1 대응이 존재하지 않는다. 대신에, 소스 기호(또는 메세지)들의 전체 스퀀스에 하나의 산술 코드 단어가 할당된다.
코드 단어 자체는 0과 1 사이의 실수 구간을 정의한다.
메세지 안의 기호 수가 증가함에 따라, 그를 나타내는 데 사용되는 간격은 더 작아지고, 구간을 표현하는 데 필요한 정보 단위(Ex. 비트)의 수는 더 커진다.
메세지의 각 기호는 발생 확률에 따라서 구간의 크기를 감소시킨다.
Huffman 접근법과 달리, 각 소스 기호가 정수 수의 코드 기호로 바뀌는 것(기호들이 한 번에 하나씩 코딩되는 것)을 요구하지 않기 때문에 Shannon의 제1정리에서 설정된 한계를 이론적으로는 달성한다.
산술 코딩의 실제 구현은 스케일링 전략과 반올림 전략을 도입하여 두 번째 문제를 다룬다.
스케일링 전략은 기호 확률에 따라 각 부구간을 분할하기 전에 각 부구간은 [0, 1) 범위로 재정규화한다.
반올림 전략은 유한 정밀도 산술과 연관된 절삭이 코딩 부구간들에 정확하게 표현되는 것을 막지 못하게 보장한다.
	<적응적 문맥 종속 확률 추정>
	코딩되는 기호들의 올바른 확률을 제공하는, 정확한 입력 기호 확률 모델을 갖고 있다면, 산술 인코더는 코딩되는 기호를 표현하는 데 요구되는 코드의 평균 개수를 최소화한다는 의미에서 거의 최적이다.
	그러나 Huffman이나 Golomb 코딩에서와 같이, 부정확한 확률 모델은 비최적화 결과로 이끈다.
	채택된 확률의 정확성을 향상시키는 간단한 방법은 적응적이며 문맥 종속적인 확률 모델을 사용하는 것이다. 적응적 확률 모델은 기호들의 지역적인 통계들에 적응한다.
	문맥 종속 모델은 코딩되는 기호들 주변의 문맥이라고 불리는 미리 정의된 이웃 화소에 기반한 확률들을 제공한다.
	보통은 이미 코딩된 기호들로 제한된 인과성 문맥이 사용된다.
	Q-인코더와 MQ-인코더가 잘 알려진 산술 코딩 기법으로 JBIG, JPEG-2000, 등 중요한 영상 압축 표준들에 통합되어 있으며, 적응적이자 문맥 종속적인 확률 모델을 사용한다.
	Q-인코더는 산술 코딩 과정의 일부인 구간 재정규화 동안 기호 확률을 동적으로 갱신한다.
	적응적 문맥 종속 모델은 또한 Golomb 코딩에도 사용되고 있다.(Ex. JPEG-LS 압축 표준)
	산술 코딩은 종종 이진 기호들이 코딩되어야 할 때 사용된다.
	각 기호(또는 비트)가 코딩 과정을 시작함에 따라, 그 문맥이 문맥 결정 블록에서 형성된다.
다양한 산술 코딩 기법들은 미국 특허로 보호되고 있다. 그렇기에, Huffman과 산술 코딩 모두에 대한 JPEG 압축 표준의 대부분이 Huffman 코딩만을 일반적으로 지원한다.
[8.2.4 LZW 코딩]
앞선 기법들은 코딩 여분성을 제거하는 데 초점이 맞춰저 있다.
LZW 코딩 역시 공간적 여분성을 처리하는 무오차 압축 접근법을 고찰한다. 이 기술은 고정-길이 코드 단어를 가변 길이의 소스 기호 시퀀스에 할당한다.
핵심적 특징은 인코딩될 기호들의 발생확률에 대한 사전 지식을 요구하지 않는다는 것이다.
GIF, TIFF, PDF를 포함하는 다양한 주류 영상화 파일 포맷들에 통합되었다.
코딩 과정이 시작할 때, 코딩될 소스 기호들을 포함하는 코드북 또는 사전이 구축된다.
8-비트 단색 영상의 경우에 사전의 처음 256개의 단어에 밝기 0, 1, 2, ..., 255를 할당한다.
인코더가 영상의 화소들을 순차적으로 조사함에 따라, 사전에 있지 않은 밝기 스퀀스들은 알고리즘적으로 결정된 위치들에 놓여진다.
사전 크기를 중요한 시스템 파라미터이다. 너무 작으면 일치하는 밝기 레벨 시퀀스를 검출할 가능성이 줄어들고, 너무 크면 코드 단어들의 크기가 압축 성능에 역효과를 준다.
LZW 코딩의 독특한 특징은 코딩 사전이나 코드북이 데이터가 인코딩되고 있는 동안에 만들어진다는 점이다.
LZW 디코더는 인코딩된 데이터 스트림을 동시에 디코딩하므로, 동일한 압축해제 사전을 구성한다.
사전의 용량이 넘치는 것에 대비하여, 가득찰 때 쏟아버리거나 재초기화하고, 새롭게 초기화된 사전으로 코딩을 계속하는 방법이 있다.
복잡한 방법으로는 압축 성능을 모니터링하여 성능이 안 좋거나 수용할 수 없을 때는 사전을 비우는 것이다.
대안으로, 가장 적게 사용되는 사전 엔트리를 탐지하여 필요에 따라 대체할 수도 있다.
[8.2.5 연속-길이 코딩]
열(또는 행)을 따라 반복되는 밝기를 갖는 영상은 동일한 밝기의 연속을 연속-길이 쌍으로 표현함으로써 압축될 수 있다.
각 연속-길이 쌍은 새로운 밝기의 시작과 그 밝기를 갖는 연속 화소 수를 규정한다.
이 기법을 연속-길이 인코딩(RLE, run-length encoding)이라 부른다.
압축은 단순한 형태의 공간 중복성, 즉 동일한 밝기의 그룹들을 제거함으로써 달성된다.
동일한 화소들의 연속이 거의(또는 전혀) 없을 때, 연속-길이 인코딩은 데이터 확장을 초래한다.
연속-길이 인코딩은 이진 영상을 압축할 때 특히 효과적이다.
두 가지의 밝기(흑백)만 존재하므로 인접 화소들이 같을 가능성이 더 높다. 게다가, 영상의 각 행은 길이와 밝기의 쌍이 아닌 단지 길이 시퀀스로 표현된다.
기본 개념은 좌에서 우로 스캔하면서 만나는 각 1 또는 0들의 인접 그룹(run)을 그의 길이로 코딩하고, 연속의 값을 결정하기 위한 규정을 정하는 것이다.
가장 흔한 규정은 각 행의 첫째 연속의 값을 정하고 각 행이 셀제로는 연속 길이가 0일 수도 있지만, 흰색 연속으로 시작한다고 가정하는 것이다.
연속 길이 자체를 가변-길이 코딩함으로써 추가적인 압축이 달성될 수 있다.
흑 및 백의 연속 길이들은 그들 자신의 통계에 특별히 맞춰진 가변-길이 코드들을 따로 사용해서 코딩될 수 있다.
가장 오래되고 널리 사용되는 영상 압축 표준들 중 두 가지는 이진 영상 압축을 위한 CCITT Group 3과 4 표준이다.
Group 3 표준은 1-D 연속-길이 코딩 기법을 사용한다. Group 4 표준은 3 표준의 간략하고 스트림라인 버전으로, 단지 2-D 코딩만이 가능하다.
	<1차원 CCITT 압축>
	1-D CCITT Group 3 압축 표준에서, 영상의 각 선은 선의 왼쪽에서 오른쪽으로 스캔에서 백과 흑 연속들의 연속 길이를 나타내는 일련의 가변-길이 Huffman 코드 단어로 인코딩 된다.
	채택된 압축 방법은 수정된 Huffman(MH) 코딩으로 불린다.
	코드 단어는 두 가지 타입으로, 종료 코드와 보완 코드로 불린다.
	EOL 코드 단어 000000000001이 새로운 영상의 첫 선을 나타내기도 하며, 선의 종료를 나타낼 때도 사용된다.
	6개의 연속적인 EOL이 영상 시퀀스의 끝을 나타낸다.
	<2차원 CCITT 압축>
	CCITT Group 3과 4의 표준 모두 채택된 2-D 압축 접근법은 선별 방법이다.
	이 방법에서는, 흑-to-백 또는 백-to-흑 연속 이행의 위치가 현재 코딩 선 상에 놓인 기준 요소의 위치에 대해서 코딩된다.
	이전에 코딩된 선을 기준 선이라고 부르며, 각각의 새로운 영상의 첫 선을 위한 기준 선은 가상의 백색 선이다.
	사용된 2-D 코딩 기법은 상대 요소 주소 지명(READ) 코딩이라 부른다.
	Group 3 표준에서, 하나 또는 셋의 READ 코딩된 선들이 연속되는 MH 코드선들 사이에 허용되는데, 이 기법을 수정된 READ 코딩이라 한다.
	Group 4 표준에서는 더 많은 READ 코딩된 선들이 허용되어, 이 방법을 재수정된 READ 코딩이라 한다.
	이 코딩은 이전 선으로부터의 정보가 현재 선을 코딩하는 데 사용된다는 의미에서 2차원적이다. 2차원 변환 자체는 관련되지 않는다.
	몇 개의 핵심 변화 요소를 찾아내는 과정이 2-D 코딩의 초기 단계에서 일어난다.
	변화 요소는 표준에 의해 그 값이 같은 선 상의 이전 화소의 값과 다른 화소로 정의된다.
	가장 중요한 변화 요소는 기준 요소이며, 각 새로운 코딩 선의 첫 화소의 왼쪽의 가상 백색 변화 요소의 위치로 설정되거나, 이전 코딩 모드로부터 결정된다.
	변화 요소들 중 어떠한 요소도 검출되지 않으면, 그들은 적당한 선 상의 마지막 화소 오른쪽의 가장 화소의 위치로 설정된다.
	현재 기준 요소 및 관련 변화 요소들을 식별한 후에, 통과/수직/수평 모드 세 가지 가능한 모드 중 하나를 선택하기 위해 2 종의 테스트가 수행된다.
	테스트들의 결과에 의존하여, 적당한 코딩 절차가 실행된다.
	그런 후 새로준 기준 요소가 다음 코딩 반복에 대비하여 알고리즘에 따라 설정된다.
[8.2.6 기호-기반 코딩]
기호 또는 토큰-기반 코딩에서, 영상은 기호라고 불리는 자주 발생하는 부영상들의 집합으로서 표현된다.
각각의 기호는 기호 사전에 저장되며 영상은 트리플릿(x, y, t)의 집합으로 코딩된다.
(x, y)는 기호의 위치, t는 사전에서 기호나 부영상의 주소이다. 각 트리플릿은 영상의 사전 기호의 한 실체(인스턴스)를 표현한다.
반복되는 기호들을 한 번만 저장한다면, 특히 기호들이 흔히 여러 번 반복되는 문자 비트맵인 문서 저장 및 검색 응용에서 영상을 많이 압축할 수 있다.
기호-기반 디코딩은 인코딩보다 훨씬 빠르다.
사전에 저장된 기호 비트맵과 그들을 참고하는 데 사용되는 트리플릿은 압축 성능을 더욱 향상시키도록 그들 자체가 인코딩 될 수 있다.
정확한 기호 매칭만 허용된다면, 결과로 얻은 압축은 무손실이다.
	<JBIC2 압축>
	2-레벨 영상 압축용 국제 표준이다. 영상을 텍스트, 하프톤, 일반 콘텐트의 중첩 영역 그리고 비중첩 영역들로 분할하여 각 콘텐트의 유형에 대해 특별히 최적화된 압축 기법을 채택한다.
	텍스트 영역은 이상적으로 기호-기반 코딩 접근법에 적합한 문자들로 구성된다.
	전형적으로, 각 기호는 텍스트의 문자를 표현하는 부영상인 문자 비트맵에 해당한다.
	JBIC2 에서는 사전의 비트앱들과 영상의 해당 문자들의 특정 실체들 사이의 차이를 무시한다. 모든 비트맵은 산술적으로 또는 MMR로 인코딩 된다.
	무손실 압축에서는 이 차이를 저장하고 각 문자를 인코딩하는 트리플릿들과 함께 사용하여 실제 영상 비트맵을 생성한다.
	사전 엔트리들에 접근하는 데 사용한 트리플릿은 살술적으로 인코딩되거나 Huffman 인코딩된다.
	하프톤 영역은 규칙적인 그리드에 배치된 패턴들로 구성된다는 점에서 텍스트 영역과 유사하다.
	그러나 사전에 저장된 기호들은 문자 비트맵이 아니라 인쇄용 2-레벨 영상을 위한 디더링된 밝기 표현하는 주기적 패턴들이다.
	일반 영역은 라인 아트와 노이즈 같은 비 텍스트, 비 하프톤 정보를 포함하고, 산술 코딩이나 MMR 코딩을 사용하여 압축된다.
JBIC2는 디코더 동작을 정의한다. 표준 인코더를 명확히 정의하지 않고 여러 형태의 인코더 설계를 허용하기에 충분히 유연하다.
인코더는 영상을 영역으로 분리하고, 사전에 저장된 텍스트와 하프톤 기호를 선택하고, 이런 기호들이 본질적으로 영상의 기호들의 잠재적 인스턴스들과 같거나 다를 때를 결정해야 한다.
디코더는 그 정보를 이용해서 원래 영상을 재생성한다.
예를 들어 텍스트를 복구할 때 판독가능하고 폰트가 같다면 인지적 무손실이라 부른다.
[8.2.7 비트-평면 코딩]
연속-길이 및 기호-기반 기법들은 개별적으로 비트 평면들을 처리함으로써 세 가지 이상의 밝기를 갖는 영상에 적용될 수 있다.
비트-평면 코딩 기법은 다중 레벨(단색 or 컬러) 영상을 일련의 이진 영상으로 분해하고, 잘 알려진 이진 압축 방법들 중 하나로 각 이진 영상을 압축하는 개념에 기반한다.
영상을 이진 영상의 집합으로 분해하는 가장 간단한 방법은 다항식의 m개의 계수들을 m개의 1-비트 비트 평면들로 분리하는 것이다.
일반적으로, 각 비트 평면은 원래 영상의 각 화소로부터의 적절한 비트들의 값이나 다항식 계수들과 같게 화소들을 설정하여 구축된다.
이 분해 접근법의 근원적인 단점은 밝기의 작은 변화가 비트 평면의 복잡성에 상당한 영향을 끼칠 수 있다는 점이다.
예를 들어 127과 128의 이진 코드의 최상위 비트(MSB)가 달라서 0에서 1로의 천이가 발생한다.
대안적 분해 접근법으로 우선 영상을 Gray 스케일로 표현한다. 그 후 비트 평면으로 전환하는 방법이 있다.
상위 비트 평면들이 하위 비트 평면들보다 훨씬 덜 복잡하다.
[8.2.8 블록 변환 코딩]
영상을 같은 크기의 중첩되지 않는 작은블록들로 나누고, 그 블록들을 2-차원 변환을 사용하여 독립적으로 처리하는 압축 기법을 고찰한다.
블록 변환 코딩에서는 역변환이 가능하고 선형적인 변환이 각 블록이나 부영상을 변환 계수들의 집합으로 매핑하기 위해 사용된다.
이들은 다시 양자화되고 코딩된다.
대부분의 영상에서 계수들의 상당수가 작은 크기를 갖고, 영상 왜곡이 거의 없이 거칠게 양자화(또는 폐기)될 수 있다.
해당 코딩은 DFT(이산 푸리에 변환)을 포함하는 다양한 변환들이 영상 데이터를 변환할 때 사용될 수 있다.
디코더는 인코더의 N*N 부영상 구성, 순방향 변환, 양자화, 기호 인코더의 네가지 연산 중 양자화를 제외한 인코더 단계의 역순으로 구현한다.
변환 과정의 목적은 각 부영상의 화소들을 비상관화하거나, 가능한 많은 정보들을 가장 작은 개수의 변환 개수들로 묶는 데 있다.
양자화 단계는 앞서 정의된 의미에서 최소량의 정보를 수반하는 계수들을 선택적으로 제거하거나 거칠게 양자화한다.
이런 계수들은 복구된 부영상 화질에 최소한의 영향을 미친다.
인코딩 과정은 양자화된 계수들을 코딩하는 것으로 종료된다.
변환 코딩의 전체 또는 일부 단계는 부영상 콘텐트에 적응적일 때 적응적 변환 코딩이라 하고, 모든 부영상들에 대해 고정적일 때는 비적응적 변환 코딩이라 한다.
	<변환 선택>
	특정 변환을 선택하는 것은 허용될 수 있는 복구 오차와 가용한 계산 자원들에 의해 좌우된다.
	압축은 변환된 계수들을 양자화하는 동안에 달성된다.
	순방향 및 역방향 변환 커널들은 계산되는 변환 유형과 그들이 채택된 블록 변환 코딩 시스템의 전체적 계산 복잡성과 복구 오차를 결정한다.
	잘 알려진 변환 커널 쌍은 DFT(이산 푸리에 변환) 쌍의 단순화 버전 그리고 변환 코딩에 유용하면서 계산적으로 보다 단순한 Walsh-Hadamard 변환이 있다.
	sin과 cos의 합인 DFT 커널들과 달리 Walsh-Hadamard 커널은 체스 패턴으로 배치된, 교차하는 양과 음의 1개로 구성된다.
	Walsh-Hadamard 변환의 중요성은 모든 커널 값이 +1 또는 -1로 구현이 간단하다는 데 있다.
	영상 압축에 흔히 사용되는 또다른 변환 중 하나는 이산 코사인 변환(DCT)이다.
	평균-제곱 복구 오차(rms)의 작은 차이들은 채택된 변환의 에너지 또는 정보 패킹 특성과 직접적으로 연관된다.
	평균 오차의 척도가 되는 M*N 영상의 평균 제곱 오차는 단일 부영상의 평균 제곱 오차와 동일하다.
	DCT의 정보 패킹 능력이 DFT나 WHT보다 우월하다.
	하지만 DCT가 아닌 Karhunen-Loeve 변환(KLT)이 정보 패킹 면에서 최적의 변환이다.
	이는 어떤 입력 영상과 유지된 변환 계수의 수에 대해서든 KLT가 평균 제곱 오차를 최소화 한다는 사실에 기인한다.
	하지만 KLT가 데이터 종속적이므로, 각 부영상들에 대한 KLT 기저 영상들을 얻는 것은 일반적으로 계산 코스트가 큰 작업이다.
	이런 이유로 KLT가 실제 영상 압축에 거의 사용되지 않는다.
	대신에 기저 영상이 고정된(입력에 독립적인) DFT, WHT, DCT 같은 변환이 보통 사용된다.
	이 중에 WHT 변환 같은 비정현 변환들이 구현하는 데 가장 간단하다.
	DFT나 DCT 같은 정현 변환들은 최적 KLT의 정보 패킹 능력 보다 가깝게 근사화한다.
	따라서 대부분은 정보 패킹 성능과 계산 복잡성의 좋은 타협점을 제공하는 DCT에 기반한다.
	입력에 독립적인 다른 변환(DFT, WHT)와 비교할 때 최대의 정보를 최소의 계수들로 패킹하고, 부영상들 사이에 경계선이 보일 때 생기는 블록 같은 형태인 블로킹 인위 구조를 최소화하면서 단일 집적 회로에 구현된 이점들을 지닌다.
	DFT는 고주파 변환 성분을 만들 때 경계 불연속을 초래한다.
	이는 변환 계수들이 절단 되거나 양자화될 때 Gibbs 현상(불연속에서 Fourier 전개가 불연속 점들의 평균값을 취한다.)이 경계들의 틀린 값을 갖게 하고, 이는 영상에 블로킹 인위 현상으로 나타난다.
	하지만 DFT가 n주기성을 갖는 반면에 DCT는 2n 주기성을 가지고, 본질적으로 경계 불연속이 없기에 블로킹 인위 현상을 감소시킨다.
	<부영상 크기 선택>
	변환 코딩의 오차와 계산의 복잡성에 영향을 주는 다른 중요한 요소는 부영상의 크기이다.
	일반적으로, 부영상의 크기가 증가함에 따라 압축 수준과 계산의 복잡성 둘 다 증가한다.
	가장 보편적인 부영상 크기는 8*8과 16*16이다.
	<비트 할당>
	절단된 급수 전개와 관련 있는 복구 오차는 남은 계수를 표현하는데 사용된 정밀도는 물론이고, 버려진 변환 계수들의 수와 상대적 중요도의 함수가 된다.
	유지될 계수들은 최대 분산(구역 코딩) 또는 임계치 최대 크기(문턱치 코딩)에 기반해서 선택된다.
	변환된 부영상의 계수들을 절단하고, 양자화하고, 코딩하는 전반적인 과정을 비트 할당이라 한다.
	<구역 코딩>
	정보를 불확실성으로 보는 정보 이론 개념에 기반한다.
	최대 분산을 갖는 변환 계수들은 가장 많은 영상 정보를 수반하며, 코딩과정에서 존속되어야 한다.
	구역 마스크는 최대 분산의 위치에는 1을 두고 다른 곳에는 0을 둔다.
	최대 분산을 갖는 계수들은 주로 영상 변환의 원점 주변에 위치한다.
	구역 샘플링 과정 동안 유지된 계수들은 양자화 및 코딩되어야 하며, 그래서 구역 마스크는 때때로 각 계수를 코딩하는 데 사용된 비트의 수를 보여주도록 명시된다. 이 때 계수들은 일반적으로 표준편차에 의해 정규화되고 균일하게 양자화 된다.
	또는 어떤 고정된 비트 수가 그들 사이에 불균등하게 배분된다. 이때, 양자화기가 각 계수에 대해서 설계된다.
	<문턱치 코딩>
	구역 코딩은 보통 모든 부영상에 대해 단일 고정 마스크를 사용하여 구현된다.
	문턱치 코딩은 각 부영상을 위해 유지된 변환 계수들의 위치가 부영상마다 변한다는 면에서 적응적이다.
	문턱치 코딩은 계산이 단순하기 때문에 많이 사용되는 적응 변환 코딩 접근법이다.
	근원적 개념은 어떤 부영상에 대해서든 최대 크기의 변환 계수들이 복원된 부영상 화질에 가장 중요한 기여를 한다는 것이다.
	부영상 문턱지 마스킹을 생성하기 위한 세 가지 기본적인 방법이 있다.
	첫 번째로 모든 부영상에 단일 전역 문턱치를 적용하는 방법이 있다.
	두 번째, 각 부영상에 대해서 다른 문턱치를 사용할 수 있으며 마지막으로, 부영상 안의 각 계수의 위치의 함수로서 문턱치가 달라질 수 있다.
	첫 방법은 압축 수준이 영상마다 다르며 전역 문턱치를 초과하는 계수의 수에 종속된다.
	두 번째 방법은 N-largest 코딩으로 불리며, 각 부영상에 대해 같은 수의 계수들이 버려진다. 코드율은 상수이고 이미 알려져 있다.
	세 번째 방법은 첫 방법처럼 가변 코드율이지만 문턱치 처리와 양자화를 결합할 수 있다.
JPEG는 가장 인기있고 포괄적인 연속 톤, 정지 프레임 압축 표준 중 하나이다.
코딩 시스템으로는 세 가지로 정의되는데, 
DCT 기반으로 하며 대부분의 압축 응용에 적합한 손실성 베이스라인 코딩 시스템, 
더 큰 압축성과 더 높은 정밀성 또는 점진적 복구 응용을 위한 확장된 코딩 시스템, 
마지막으로 기역적 압축을 위한 무손실 독립 코딩 시스템이 있다.
JPEG와 호환되기 위해서는 제품 또는 시스템은 베이스라인 시스템을 위한 지원을 포함해야 한다.
특별한 파일 포맷, 공간 해상도, 칼라 공간 모델은 정해지지 않는다.
순차 베이스라인 시스템이라 불리는 베이스라인 시스템에서 입력과 출력 데이터 정밀도는 8비트로 제한된다.
반면 양자화 DCT는 11비트로 제한된다.
압축 자체는 DCT 계산, 양자화, 가변-길이 코드 할당의 3단계로 수행된다.
[8.2.9 예측 코딩]
각 화소에서 새로운 정보만 추출하고 코딩해서 가까운 화소들의 중복성을 제어하는 것에 기반한다.
한 화소의 새로운 정보는 화소의 실제 값과 예측 값 사이의 차이로서 정의된다.
이 접근법은 계산 오버헤드 없이 좋은 압축을 달성하고 무오차 또는 손실성일 수 있다.
	<무손실 예측 코딩>
	시스템은 각각 동일한 예측기를 포함하는 인코더와 디코더로 구성된다.
	이산 시간 입력 신호의 연속된 샘플들이 인코더에 들어옴에 따라 지정된 수의 과거 샘플들에 기반해서 예측기가 각 샘플의 예측치를 생성한다.
	예측기의 출력은 가장 가까운 정수로 반올림되며, 예측 오차를 형성하는 데 사용된다.
	이는 업축된 데이터 스트림의 다음 요소를 생성하기 위해 가변-길이 코드를 사용하여 기호 인코더에 의해 인코딩 된다.
	디코더는 수신된 가변-길이 코드 단어들로부터 복구하고, 원래 입력 시퀀스를 압축해제 또는 재생성하기 위한 역연산을 수행한다.
	예측기에서는 지역적, 전역적, 적응적인 방법들이 사용된다. 대부분, 예측은 m개의 이전 샘플들의 선형 조합으로 만들어진다.
	m개의 샘플 중 처음 m 화소에 대해서는 다른 샘플(스캔 선)을 이용하여 평가할 수 없기에 Huffman 코드 같은 다른 수단으로 코딩되어야 하며, 이는 오버헤드로 간주되어야 한다.
	예측 코딩으로 달성된 압축이, 입력 영상을 흔히 예측 오차라 부르는 예측 오차 시퀀스로 매핑하는 것에 의한 엔트로피 감소와 직접적으로 관련된다.
	공간 중복성은 예측 및 차동 과정에서 제거되기에, 예측 오차의 확률 밀도 함수는 0에서 높은 피크를 이루며, 비교적 작은 분산을 가진다.
	<움직임 보상 예측 오차>
	비디오 시퀀스의 연속되는 프레임들은 매우 유사하다. 이들의 차이를 코딩하면 시간 중복성을 줄이고 상당한 압축을 제공할 수 있다.
	하지만 프레임 시퀀스가 급히 이동하는 물체, 또는 카메라 줌과 패닝 또는 갑작그런 장면 변화, 페이드 인/아웃 시에 프레임들 사이에 유사성이 감소하고 압축에 부정적인 영향을 미친다.
	대부분의 압축 기법들 같이, 시간-기반 예측 코딩은 특정 종류의 입력, 즉 상당한 시간 중복성을 지닌 영상 시퀀스에 잘 적용된다.
	거의 시간 중복성이 없는 영상을 사용할 때는, 데이터 확장이 일어날 수 있다.
	비디오 압축 시스템은 다음 두 가지 방법으로 데이터 확장 문제를 피한다.
	1. 물체의 움직임을 추적하고 예측 및 차분 과정 중에 보상한다.
	2. 예측 코딩을 유리하게 만들기에는 프레임 간 상관관계(프레임 간 유사성)가 불충분할 때는
	   다른 대안 코딩 방법으로 전환한다.
	첫 번째 방법은 움직임 보상으로 불린다.
	일반적으로 프레임 간 상관관계가 불충분할 때는 두 번째 방법이 JPEG의 DCT-기반 코딩 같은 블록 중심 2-차원 변환을 사용해서 다뤄진다.
	이러한 방법으로 압축된 프레임들을 내부 프레임 또는 독립(I) 프레임이라 부른다.
	I-프레임들을 보통 JPEG 인코딩된 영상을 닮으며, 예측 오차를 생성하기 위한 이상적 시작 점이다.
	I-프레임들은 고도의 랜덤 접근성, 편집 용이성, 전소 오차 파급 차단성을 제공한다.
	모든 표준들은 압축된 비디오 코드 스트림에 I-프레임을 주기적으로 삽입할 것을 요구한다.
기준 프레임이라 불리는 이전(또는 다음) 비디오 프레임에서 가장 가능성 있는 위치에 관한 각 매크로 블록의 움직임이 움직임 벡터에 인코딩된다.
해당 벡터는 가장 가능성 있는 위치로부터의 수평, 수직 변위를 정의함으로써 움직임을 묘사한다.
이 변위는 보통 가장 가까운 화소나 1/2, 1/4 화소의 정밀도로 지정된다.
부화소 정밀도가 사용된다면 예측들은 기준 프레임 화소들의 조합으로부터 내삽되어야 한다.
이전 프레임에 기반해서 인코딩된 프레임은 예측(P) 프레임이라 부른다.
다음 프레임에 기반한 프레임은 양방향(B) 프레임이라 부른다.
B-프레임들은 원래의 표시 순서가 아닌, 적절한 디코딩 시퀀스로 프레임들이 디코더에 제시되도록 압축된 코드 스트림이 재정렬될 것을 요구한다.
움직임 추정은 움직임 보상의 핵심 요소이다. 움직임 추정 동안, 물체의 움직임이 측정되고 움직임 벡터로 인코딩된다.
최상의 움직임 벡터의 탐색은 최적의 기준이 정의될 것을 요구한다. 예를 들어 움직임 벡터는 선택된 기준 프레임에서 매크로블록 화소들과 예측된 화소들(또는 부화소 움직임 벡터들을 위한 보간 화소들) 사이의 최대 상관관계나 최소 오차를 근거로 선택할 수 있다.
일반적으로 사용하는 오차 척도 중 하나는 평균 절대 왜곡(MAD, mean absolute dsistortion)이다.
MAD(x, y)를 최소화하는 dx, dy를 탐색하여 움직임 추정을 수행하는 것을 블록 매칭이라 한다.
철저한 탐색은 좋은 결과를 보장하지만, 모든 가능한 움직임이 전체 변위 범위에 걸쳐 테스트해야 하기에 계산 비용이 크다.
움직임 추정은 많은 계산을 요구하는 작업이다. 인코더만이 매크로 블록 움직임을 추정한다.
매크로블록들의 움직임 벡터들이 주어지면, 디코더는 예측 오차를 형성하기 위해서 인코더에서 사용했던 기준 프레임들의 영역을 접근한다.
그렇기 때문에, 움직임 추정은 대부분의 비디오 압축 표준에 포함되지 않는다.
표준의 대부분은 I-프레임 인코딩에 8*8 DCT를 사용하지만, 움직임 보상을 위해서 보다 큰 영역을 명시한다.
P-프레임과 B-프레임 예측 오차들도 DCT 계수 양자화의 효과 때문에 변환 코딩된다.
H.264, MPEG-4 AVC 표준이 공간 중복성을 줄이기 위해 프레임 내 예측 코딩을 지원한다.
인코더의 예측이 대응하는 디코더 예측과 일치하도록 인코더는 역 양자화기와 역 매퍼(Ex. 역 DCT)를 포함한다.
또한 의도한 비디오채널의 용량과 일치하는 압축된 비트 스트림을 산출하도록 설계된다.
	<손실성 예측 코딩>
	무손실 예측 코딩 모델에 양자화기를 추가하고, 공간 예측기의 맥락에서 복구 정확도와 압축 성능 사이의 절충이다.
	무오차 인코더의 최근접 정수 함수를 대체하는 양자화기가 기호 인코더와 예측 오차가 형성되는 점 사이에 삽입된다.
	양자화기의 출력은 압축과 발생한 왜곡량을 정한다.
	양자화 단계 삽입을 수용하기 위해서는 인코더와 디코더로 생성된 예측들이 같아야 한다.
	이는 손실성 인코더의 예측기를 피드백 루프 안에 넣어서 달성될 수 있다.
델타 변조(DM)는 간단하면서도 잘 알려진 형태의 손실성 예측 코딩이다.
급격히 변하는 영역에서, 기울기 과부화라고 하는 왜곡이 발생한다.
또는 입력의 작은 변화를 표현할 수 없어 평탄한 영역에서는 입자 모양 노이즈가 나타난다.
이러한 두 가지 현상으로 경계선이 흐려지고 표면에 낱알 모양의 노이즈가 나타나 부드러운 영역들이 왜곡된다.
이러한 왜곡들은 모든 형태의 손실 예측 코딩에서 공통으로 발생한다.
예측기는 보통 양자화 오차가 없다는 가정 하에 설계되고, 양자화기는 자신의 오차를 최소화하도록 설계된다. 즉, 예측기와 양자화기는 서로 독립적으로 설계된다.
	<최적 예측기>
	많은 예측 코딩 응용에서, 예측기는 인코더의 평균 제곱 예측 오차를 제한 조건하에 최소화하도록 선정된다.
	즉, 최적화 기준은 최소 평균 제곱 예측 오차이고, 양자화 오차는 무시될 수 있다고 가정되며, 예측은 m개의 이전 샘플들의 선형 조합으로 제한된다.
	제한은 필수적이진 않으나, 분석을 상당히 단순화시키고, 동시에 예측기의 계산 복잡성을 감소시킨다.
	결과 예측 코딩 접근법을 차동 펄스 코드 변조(DPCM)라 한다.
	예측 계수들이 각 입력 시퀀스에 대해 계산되는 지역적 예측은 거의 사용되지 않는다.
	대부분 간단한 입력 모델을 가정하고 전역적 계수들의 집합을 계산한다.
	예측 계수들의 합은 보통 1 이하여야 한다. 이 제한은 예측기의 출력이 허용된 입력 범위 안에 놓이는 것을 보장하고, 전송 노이즈의 영향을 감소시키기 위해 수립된다.
	전송 노이즈는 디코더의 입력에 포함되게 되고, 하나의 오차가 모든 미래 출력에 전파될 수 있기 때문에 DPCM 디코더의 입력 노이즈에 대한 민감성을 줄이지 않으면 디코더의 출력이 불안정하게 될 수 있다.
	엄격하게 1보다 작게 더 제한하면 입력 오차의 영향은 작은 수의 출력들에 한정된다.
시각적으로 인지 가능한 오차는 예측기의 차수가 증가함에 따라 감소한다.
예측 오차들의 표준편차들은 유사한 패턴을 따른다.
	<최적 양자화>
	계단 양자화 함수에서 끊긴 점들은 양자화기의 판정 및 복구 레벨이라 불린다.
	Lloyd-Max와 최적 균등 양자화기는 적응적이지 않지만, 영상의 지역적 형태에 근거하여 양자화 레벨을 조정할 수 있다.
	이론적으로, 천천히 변화하는 영역들은 세밀하게 양자화될 수 있고, 급격하게 변하는 영역은 더 거칠게 양자화된다.
	이 접근법은 최소한도의 코드율 증가만을 요하지만 입상(자갈 모양) 노이즈와 기울기 과부화 모두를 동시에 감소시킨다. 하지만 양자화기의 복잡성이 증가한다.
[8.2.10 웨이블릿 코딩]
웨이블릿 코딩은 영상의 화소들을 비상관시키는 변환의 계수들이 원래 화소들 자체보다 더 효율적으로 코딩될 수 있다는 아이디어에 근거하고 있다.
웨이블릿 변환의 기저 함수들이 중요한 시각적 정보들의 대부분을 작은 수의 계수들로 집약한다면, 나머지 계수들은 거의 영상의 왜곡 없이 거칠게 양자화되거나 0으로 절삭될 수 있다.
웨이블릿 변환의 계산된 계수들의 다수가 시각적은 정보를 거의 지니고 있지 않기 때문에, 계수간 중복성과 코딩 중복성 최소화를 위해 양자화되고 인코딩될 수 있다.
연속-길이, Huffman, 산술, 비트 평면 코딩과 같은 무손실 코딩 방법들은 최종 기호 코딩 단계로 편입될 수 있다.
디코딩은 정확하게 역으로 될 수 없는 양자화를 제외하고 인코딩 과정을 거꾸로 한다.
웨이블릿 기반 시스템과 변환 코딩 시스템의 주요 차이점은 변환 인코더의 부영상 처리 과정이 생략된 점이다.
웨이블릿 변환은 계산상 효율적이고 본질적으로 지역적이므로, 원래 영상의 부분할은 불필요하다.
부분할 단계의 제거는 고압축률에서 DCT-기반 근사화의 특징이 되는 블로킹 인위 구조를 제거한다.
	<웨이블릿 선택>
	순방향과 역방향 변환의 기저로 선택된 웨이블릿들은 웨이블릿 코딩 시스템의 설계와 성능에 영향을 끼친다.
	변환들의 계산상 복잡성에 직접적인 영향을 주고, 허용 가능한 오차 안에서 영상을 압축하고 복구하는 시스템 능력에는 덜 직접적으로 영향을 준다.
	변환 웨이블릿이 짝 스케일링 함수를 가질 때, 필터 탭의 수가 0이 아닌 웨이블릿 및 스케일링 벡터 계수의 수와 같은 일련의 디지털 필터링 연산으로 구현될 수 있다.
	정보를 작은 수의 변환 계수로 집약하는 웨이블릿의 능력은 그의 압축과 복구 성능을 결정한다.
	웨이블릿-기반 압축에 가장 많이 사용되는 전개 함수는 Daubechies 웨이블릿과 쌍직교 웨이블릿이다.
	쌍직교는 0적률의 수와 같은 유용한 분석 특성들이 분해 필터에 편입될 수 있게 해준다.
	복구의 부드러움 같은 중요한 합성 특성들은 복구 필터로 편입된다.
	Haar, Daubechies, 심릿, 쌍직교 등이 사용될 수 있으며 모두 고속 웨이블릿 변환을 통하여 계산될 수 있고, 계산 상 복잡도(필터의 탭 수)가 증가함에 따라 정보 패킹 성능도 좋아진다.
	<분해 레벨 선택>
	웨이블릿 코딩의 계산상 복잡성 및 복구 오차에 영향을 주는 또 다른 요인은 변환 분해 레벨 수이다.
	P-스케일 고속 웨이블릿 변화은 P-필터 뱅크 반복들을 포함하므로 순방향과 역방향 변환 계산의 연산수는 분해 레벨 수에 따라 증가한다.
	더 많은 분해 레벨로 더 낮은 스케일의 계수들을 양자화하는 것은 복구 영상의 더 큰 영역에 영향을 미친다.
	보통 저장 또는 전송된 영상들의 해상도와 유용한 최저 근사화의 스케일이 변환 레벨 수를 정한다.
	<양자화기 설계>
	웨이블릿 코딩 압축 및 복구 오차에 영향을 끼치는 가장 중요한 요인은 계수 양자화이다.
	대부분의 양자화기들은 균일하지만, 데드 존으로 불리는 0의 주변에서 양자화 간격을 보다 크게 하거나, 스케일에 따라서 양자화 간격의 크기를 적응적으로 하여 양자화 효과를 향상시킬 수 있다.
	어느 경우든, 선택된 양자화 간격은 인코딩된 영상 비트 스트림과 함께 디코더에 전달되어야 한다.
	간격 자체는 경험적으로 결정되거나, 압축될 영상에 기반해서 자동으로 계산될 수 있다.
	데드 존의 크기가 증가함에 따라 절단된(0이 된) 계수들의 수도 증가한다.
	<JPEG-2000>
	JPEG 표준을 확장해서 연속-톤 정지 영상의 압축과 압축 데이터에 대한 접근 모두에서 증가된 유연성을 제공한다.
	웨이블릿 코딩 기법에 기반한다.
	계수 양자화는 개별 스케일과 부대역들에 적응되며, 양자화된 계수들은 비트-평면 기저에 산술적으로 코딩된다.
	여기서 타일이라는 성분이 나오는데, 타일들은 독립적으로 처리되는 화소들의 직각사각형 배열들이다.
	타일은 타일링이라는 과정을 통해 생성된다.
	변환은 고속 웨이블릿 변환은 사용하거나 상보적 리프팅-기반 접근법을 통해 계산된다.

[8.3 디지털 영상 워터마킹]
불법적인 복제를 막기 위한 방법을 총괄하여 워터마킹이라 부른다.
워터마킹된 영상에 없어서는 안 될 중요한 요소로서, 워터마크는 다음을 포함하는 다양한 방식으로 저작권을 보호한다.
1. 판권 식별, 워터마크는 소유권이 침해되었을 때 소유권을 증명해주는 정보를 제공한다.
2. 사용자 식별 또는 지문 감정, 합법적 사용자들의 신원은 워터마크에 인코딩된다.
3. 정통성 판정, 워터마크가 원본을 조금만 수정해도 파손되도록 설계되었다는 가정하에 워터마크의 존재는 변경되지 않았음을 보증할 수 있다.
4. 자동 감시, 워터마크는 언제 어디서 영상을 사용되는지 추적하는 시스템에 의해 감시될 수 있다.
5. 복사 방지, 워터마크가 영상 사용 및 복사 규정을 명시할 수 있다.
워터마킹과 압축은 공통점이 없다.
압축은 영상 표현에 사용되는 데이터의 양을 줄이는 것인 반면, 워터마킹은 정보와 데이터(즉, 워터마크)를 영상에 추가하는 것이다.
가시적 워터마크는 관찰자에게 분명하도록 다른 영상의 위에 위치하게 되는 불투명하거나 반투명한 부영상이나 영상이다. 일반적으로 공간 도메인에서 수행된다.
비가시적 워터마크는 육안으로 볼 수 없다. 하지만 적절한 해독 알고리즘으로 복구될 수 있다.
그렇기에 시각적으로 없어도 무방한 정보를 삽입하여 확보한다.
예를 들어 영상의 최하위 비트들은 영상을 인지하는 데 거의 영향을 끼치지 못하여, 최하위의 두 비트에 삽입할 수도 있다. 이를 LSB(최하위 비트) 워터마킹 영상이라 한다.
비가시적 워터마크의 중요한 특성 중 하나는 우발적이거나 의도적으로 제거하려는 시도에 대한 내성이다.
영상이 조금만 변경되도 섬세한 비가시적 워터마크는 파괴된다. 예를들어 LSB 워터마킹 영상이 손실성 JPEG를 사용하여 압축 및 압축해제 된다면 워터마크는 파괴된다.
견고한 비가시적 워터마크는 공격이 의도적이든 의도적이지 않든 영상 변경 후에도 살아남을 수 있다.
비의도적 공격에는 손실성 압축, 선형/비선형 필터링, 잘라내기, 회전, 재표본화 등이 있다.
의도적 공격은 출력과 재스캐닝에서부터 부가적 워터마크와 노이즈 추가까지 포함된다.
영상 자체를 사용하지 못하게 만드는 공격에 내성을 갖게 할 필요는 없다.
마크 삽입과 추출은 공간 도메인에서 수행될 수 있지만, 변환 도메인에서도 수행될 수 있다. 대표적인 예시로 DCT-기반 워터마킹 접근법이 있다.
비공개 또는 제한 키 방법이기 때문에, DCT-기반 워터마킹 접근법은 공격에 상당히 안전하다.
제한 키 방법은 비 제한 키 방법보다 항상 더 탄력적이다.