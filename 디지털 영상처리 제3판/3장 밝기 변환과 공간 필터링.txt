[3. 밝기 변환과 공간 필터링]
공간 도메인이란 영상 평면 자체를 가리키며 영상 처리 방법들은 영상 화소들을 직접 조작하는 것에 기반한다. 우선 영상을 변환 도메인으로 변환하고, 거기에서 처리한 뒤에, 그 결과를 공간 도메인으로 되가져오는 역변환을 구하는 것을 포함하는 변환 도메인에서의 영상 처리와 대조된다.
영상 처리의 두 가지 쥬요 부류는 밝기 변환과 공간 필터링이다. 밝기 변환은 주로 콘트라스트 조작과 영상 문턱치 처리를 목적으로 하여 영상의 각각의 화소에 작용한다.
공간 필터링은 영상의 각 화소의 이웃에 적용되어 영상 샤프닝 같은 연산을 수행한다.
[3.1 배경]
[3.1.1 밝기 변환과 공간 필터링의 기초]
공간 도메인 기법들은 영상의 화소들에 직접 작용한다. 어떤 영상 처리 작업은 공간 도메인에서 구현하는 것이 더 쉽거나 의미가 있는 반면, 다른 접근법이 더 적합한 것들도 있다.
일반적으로 공간 도메인 기법들이 계싼적으로 더 효율적이며, 구현에도 더 적은 프로세싱 자원이 소요된다.
g(x, y) = T[f(x, y)], 여기서 f(x, y)는 입력 영상, g(x, y)는 출력 영상, T는 점 (x, y)의 이웃에 대해 정의된 f에 대한 연산자이다. 이 연산자는 단일 영상에 대해 적용될 수도 있고, 노이즈 축소를 위해 영상 시퀀스의 화소 대 화소 합을 계산하는 것과 같이 일련의 영상들에 적용될 수도 있다. 임의의 위치 (x, y)에서의 출력 영상 g의 값은 f의 (x, y)에 원점이 있는 이웃에 T를 적용한 결과와 같다. 예를들어, 이웃이 크기가 3*3인 정사각형이고 연산자 T가 "이우스이 평균 밝기 계산"하는 것이라면, 영상의 (100, 150) 위치를 고려해보자. 이웃의 원점이 그 중앙에 있다고 가정하면, 그 위치에서 결과인 g(100, 150)은 f(100, 150)과 그 8-이웃합이 9로 나뉜 값(즉, 이웃에 포함되는 화소들의 평균 밝기)으로 계산된다. 그 뒤, 이웃의 원점이 그 다음 위치로 이동되고, 위 절차가 반복되어 출력 영상 g의 다음 값을 만든다. 일반적으로, 이 과정은 입력 영상 왼쪽 위에서 시작해서 수평 방향으로 한 화소씩, 그리고 한 번에 한 행씩 진행한다. 이웃의 원점이 영상의 경계에 있을 때는 이웃의 일부가 영상 바깥에 놓일 것이다. 그러면 바깥 이웃들을 무시하고 T로 규정된 계산을 수행하거나, 0또는 다른 지정된 밝기 값들의 경계로 영상을 패딩하여 계산한다. 패딩된 경계의 두께는 이웃의 크기에 종속된다. 
기술된 절차는 미리 정의된 연산과 함께 이웃이 공간 필터(공간 마스크, 커널, 템플릿, 윈도우와 같이 불림)로 불리는 공간 필터링이라고 불린다. 가장 작은 이웃의 크기는 1*1이다. 이 경우 g가 단일 점 (x, y)에서의 f값에만 종속되며, T는 형태의 밝기(그레이 레벨 OR 매핑) 변환 함수가 된다.
s = T(r), s와 r은 각각 점 (x, y)에서의 g와 f의 밝기를 나타내는 변수들이다. 일정 레벨 이하의 밝기 들은 어둡게 / 높은 레벨의 밝기들은 밝게 만들어서 원래 영상보다 높은 콘트라스트를 갖는 영상을 만들게 된다. 이는 콘트라스트 스트레칭으로도 불리는 기법으로, k보다 낮은 r 값은 변환 함수에 의해 검은색 쪽으로, s의 좁은 범위에 압축되고, k보다 높은 r값들은 그 반대로 작용한다.
결과가 한 점에서의 밝기에만 종속되는 접근법을 점 처리 기법이라고 부르기도 한다.
[3.2 기본적 밝기 변환 함수들]
밝기 변환은 영상 처리 기법 중 가장 간단한 축에 든다. 처리 전후의 화소 값들이 각각 r과 s로 표기된다. 이 값들은 s=T(r) 형태의 식에 의해 관련되며, 여기서 T는 화소 값, r은 화소 값 s로 매핑하는 변환이다.
변환 함수의 값은 일반적으로 1-D 배열에 저장되며, r에서 s로의 매핑은 테이블 룩업(표 검색)에 의해 구현된다. 8-비트 환경에서 T 값들을 담고 있는 룩업 테이블은 256개의 요소를 가질 것이다.
영상 개선을 위해 자주 사용되는 세 가지 기본 함수 유형은 선형(네거티브 및 항등 변환들), 로가리듬(로그 및 역-로그 변환등), 거듭제곱-법칙(또는 멱승 법칙. n차 거듭제곱 및 n차 제곱근 변환들)이 있다.
항등 함수는 출력 밝기가 입력밝기와 같은 사소한 경우이다.
[3.2.1 영상 네거티브]
밝기 레벨의 범위가 [0, L-1]인 영상의 네거티브는 다음 네거티브 변환에 의해 만든다.
s = L -1 - r, 영상의 밝기를 반전시키면 사진 네거티브와 똑같은 것을 만든다. 이 유형의 처리는 흑색 영역의 면적 비중이 클 때, 영상의 어두운 영역에 놓여 있는 흰색이나 그레이 디테일을 개선시키는 데 특히 적합하다.
[3.2.2 로그 변환]
로그 변환의 일반형은 s=clog⁡(1+r) 이다. 여기서 c는 상수이며, r>=0으로 가정된다. 이 변환은 입력의 낮은 밝기 값들의 좁은 범위를 넓은 범위의 출력 레벨들로 매핑한다. 높은 값의 입력 레벨들에 대해서는 그 반대다.
입력의 어두운 화소들의 값을 신장시키고, 높은 레벨들의 값을 압축하고자 할 때 이 변환을 사용한다. 역 로그 변환은 그 반대이다.
영상 밝기 레벨 신장/압축은 거듭제곱-법칙 변환이 이 목적을 위해 더 유연하게 작용한다.
로그 함수는 화소 값들의 편차가 큰 영상의 동적 범위를 압축하는 중요한 특성을 가진다. 화소 값들이 큰 동적 범위를 갖는 고전적 예는 푸리에 스펙트럼이 있다.
[3.2.3 거듭제곱-법칙(Gamma) 변환]
기본 형태는 s = cr^γ 이다. c와 γ는 양의 실수이다. 오프셋을 감안하기 위해 때때로 식을 s = c(r + ε)^γ로 쓴다. 그러나 오프셋은 일반적으로 표시기 보정의 문제이며, 보통 무시된다.
1보다 작은 γ 값에 대한 거듭제곱-법칙 곡선들은 좁은 범위의 어두운 입력 값들을 넓은 범위의 출력 값들로 매핑하며, 더 큰 값의 입력 레벨들에 대해서는 그 반대이다. 그러나 로그 함수와 달리, 단순히 γ 값을 바꿔서 얻어지는 가능한 변환 곡선 군을 보면, γ > 1로 생성된 곡선들은 γ < 1로 생성된 곡선들과 정반대의 효과를 보인다. c = γ = 1 일때는 항등 변환으로 축소된다.
영상 포착, 인쇄, 표시 등에 사용되는 다양한 장치들은 거듭제곱-법칙의 특성을 따른다. 관습적으로, 거듭제곱-법칙 공식의 멱 지수를 Gamma 라고 부른다. 이 거듭제곱-법칙 반응 현상을 보정하는데 사용되는 프로세스를 Gamma 보정이라고 부른다. 스캐너, 프린터 등의 모니터 외의 영상화 장치들에서도 비슷한 보정이 적용된다. 유일한 차이는 Gamma 값이 장치마다 달라진다는 점이다.
Gamma 보정은 컴퓨터 스크린에 영상을 정확하게 표시해야 할 때 중요하다. 칼라를 정확하게 재현하는 데에도 gamma 보정에 대한 지식이 어느 정도 필요한데, 그 이유는 gamma 값을 바꾸면 밝기 뿐만 아니라 칼라 영상의 RGB 비도 바뀌기 때문이다.
Gamma 보정 외에도, 거듭제곱-법칙 변환은 범용 콘트라스트 조작에 유용하다.
[3.2.4 구간 선형 변환 함수]
앞선 방법들에 대한 보완적인 접근법으로 구간 선형 함수를 사용하는 것이 있다.
구간 선형 함수의 중요한 장점은 형태가 임의로 복잡해질 수 있다는 것이다. 구간 함수의 중요한 단점은 실질적 구현이 구간 함수들로서만 공식화될 수 있는 것을 규정하는데 사용자 입력이 훨씬 더 많이 필요하다는 것이다.
[콘트라스트 스트레칭]
가장 간단한 구간 선형 함수 중 하나는 콘트라스트-스트레칭 변환이다. 낮은 콘트라스트 영상의 원인은 나쁜 조명, 영상화 센서의 좁은 동적 범위, 영상 획득 시 잘못된 조리개 설정 등일 수 있다.
콘트라스트 스트레칭은 영상의 밝기 레벨 범위를 넓혀서 기록 매체나 표시 장치의 전체 밝기 범위를 사용하게 하는 것이다. 처리된 영상에서 인위적 밝기 구조가 생기는 것을 방지한다.
[밝기-레벨 슬라이싱]
영상의 특정 밝기 범위를 강조하는 게 자주 필요하다. 그 응용에는 인공위성 영상에서 물이 모여 있는 곳과 같은 특징들을 강조하거나 X-선 영상에서 결함을 강조하는 것 등이 해당한다.
밝기-레벨 슬라이싱이라 불리는 이 프로세스는 몇 가지 방법으로 구현될 수 있으나, 대부분 두 가지 기본형이 변형된 것들이다.
첫 번째는 관심 영역에 드는 모든 값들을 한 값으로 표시하고, 나머지 밝기 값들을 다른 값으로 표시하는 것이다. 두 번째 접근법은 원하는 밝기 범위를 밝게(또는 어둡게 만들고), 나머지 밝기 레벨은 그대로 놔둔다.
[비트-평면 슬라이싱]
화소는 비트들로 구성된 디지털 수이다. 예로, 256-레벨 그레이 스케일 영상은 각 화소의 밝기는 8비트로 구성된다. 밝기-레벨 범위를 강조하는 대신, 전체 영상 모양에 대한 특정 비트의 기여를 강조할 수 있다.
영상의 모든 화소 값은 비트 평면들의 해당 이진 값 화소들로부터 마찬가지로 복구될 수 있다. 8-비트 영상의 8번째 비트 평면에 대한 이진 영상이, 0~127 사이의 밝기는 0으로 매핑, 128~255 사이의 레벨은 1로 매핑하는 밝기 문턱치 처리 변환 함수로 입력 영상에서 얻어질 수 있다.
영상을 비트 평면들로 분해하는 것은 영상에서의 각 비트의 상대적 중요성을 분석하는 데 유용하다. 이 프로세스는 영상 양자화에 사용되는 비트 수의 적절성을 판단하는 데 도움이 된다. 또한 이 유형의 분해는 일부 평면만 영상 복구에 사용되는 영상 압축에 유용하다. 이는 n번째 평면의 화소들을 상수 2^(n-1)로 곱해서 수행된다. 이것은 바로 n번째 MS 비트를 십진수로 전환하는 것이다. 최상위 네 개의 비트 평면으로만 복구해도 만족할만한 디테일을 가진 원본을 복구할 수 있다.
[3.3 히스토그램 처리]
밝기레벨의 범위가 [0, L-1]인 디지털 영상의 히스토그램은 이산 함수 h(r_k) = n_k이다. 여기서 r_k는 k번째 밝기 값이며, n_k는 영상에서 밝기 r_k를 갖는 화소들의 수이다. 보통 히스토그램의 성분 각각을 영상의 전체 화소 수로 나누어 히스토그램을 정규화한다. 영상의 전체 화소 수는 MN이며, 항상 M과 N은 각각 영상의 행과 열 수이다. 따라서 정규화된 히스토그램은 p(r_k) = n_k / MN 이다. 여기서 k = 0, 1, ..., L-1이다. 대략적으로 p(r_k)는 영상에서 밝기 레벨 r_k가 발생할 확률의 추정이다. 정규화된 히스토그램의 모든 요소의 합은 1이다.
히스토그램은 많은 공간 도메인 처리 기법들을 위한 기초이다. 유용한 영상 통계를 제공하는 외에도, 히스토그램에 고유한 정보는 영상 압축, 분할 같은 다른 영상 처리 응용에서도 매우 유용하다. 이는 실시간 영상 처리를 위한 인기 있는 도구이다.
히스토그램은 단순히 [h(r_k) = n_k : r_k] 또는 [p(r_k) = n_k/MN : r_k]의 그래프로 볼 수 있다. 입력 영상의 히스토그램에서 얻을 수 있는 정보에만 기반해서 콘트라스트를 자동으로 조정하는 변환 함수를 개발하는 것도 가능하다.
[3.3.1 히스토그램 평활화]
처리될 영상의 밝기를 r이라고 나태낼 때, r의 범위가 [0, L-1]이며, r=0는 검은색, r=L-1은 흰색을 나타내는 것으로 하자, 이런 조건의 R에 대해 다음 형태의 변환(밝기 매핑)에 초점을 맞춘다.
s = T(r), 0 <= r <= L-1
이 공식은 밝기 레벨 r을 갖는 입력 영상의 모든 화소에 대해 출력 밝기 레벨 s를 만든다. 이 때 다음과 같은 가정을 한다.
(a) T(r)은 0 <= r <= L-1 구간의 단조 증가 함수이다.
(b) 0 <= r <= L-1에 대해 0<=T(r)<=L-1이다.
r = T^(-1)(s), 0<=s<=L-1 역에 대한 조건으로는 (a)를 다음과 같이 바꾼다.
(a') T(r)은 0<=r<=L-1 구간의 엄밀 단조 증가 함수이다.
T(r)이 단조 증가해야 한다는 조건 (a)의 요건이 출력 밝기 값이 해당 입력 밧보다 결코 작지 않게 보장하므로, 밝기의 역 함수에 의해 생기는 인위적 구조를 방지한다.
조건 (b)는 출력 밝기 범위가 입력에서와 같음을 보장한다. 마지막으로 (a')은 s로부터 r로 되돌아오는 매핑이 1:1이 되는 것을 보장하기 때문에 모호성을 방지한다.
실제로는 정수 밝기 값을 다루기 때문에, 모든 결과 값은 최근접 정수로 정수화된다. 그러므로 엄밀 단조성이 충족되지 않으면, 가장 가까운 정수 짝을 찾아서 역변환 문제를 처리한다.
영상의 밝기 값을 구간 [0, L-1]의 랜덤 변수로 볼 수 있다. 랜덤 변수의 기본적 묘사자는 확률 밀도 함수(PDF)이다. r과 s의 PDF들을 각각 p_r(r)과 p_s(s)로 나타낸다고 하자. 기초 확률 이론으로부터 알 수 있는 것은, 만일 p_r(r)과 T(r)이 알려져 있고 T(r)이 관심 값 범위에서 연속적이고 미분 가능하다면, 변환(매핑)된 변수 s의 PDF는 다음의 간단한 공식을 사용해서 얻을 수 있다는 것이다.
p_s(s) =p_r(r)|dr/ds|, 따라서 출력의 밝기 변수 s의 PDF는 입력 밝기의 PDF와 사용된 변환 함수에 의해 결정된다. 영상 처리에서 특별히 중요한 변환 함수는 다음의 형태를 가진다.
s=T(r)=(L-1)∫_0^r(P_r(ω)dω), 여기서 ω는 적분 변수이다. 우변은 랜덤 변수 r의 누적 분포 함수(CDF)이다. 
p_s(s)를 구하기 위해 Leibniz 규칙으로부터, 상한에 관한 정적분의 미분은 그 한계에서 계산된 피적분 함수임을 알고있다. 이를 통해 식을 전개하면 p_s(s)의 형태는 균등 확률 밀도 함수라는 걸 알 수 있다. 즉, 밝기 변환을 수행하면 균등 PDF 특성의 랜덤 변수 s가 나옴을 알 수 있다.
T(r)은 p_r(r)에 종속되지만, p_s(s)는 p_r(r)의 형태와 무관하게 항상 균등하다.
이산 값들에 대해서는 확류 밀도 함수와 적분 대신에 확률(히스토그램 값)과 합을 사용한다.
디지털 영상에서 밝기 레벨 r_k가 발생할 확률은 대략
p_k(r_k) = n_k / MN, k = 0, 1, 2, ..., L-1 이다.
MN은 영상 전체의 화소 수, n_k는 밝기 r_k를 갖는 화소 수, L은 영상의 가능한 밝기 레벨 수(8-비트 영상은 256)이다. p_r(r_k) : r_k의 그래프를 보통 히스토그램이라고 부른다.
처리된 출력 영상은 밝기가 r_k인 입력 영상의 각 화소를 이용해서 출력 영상에서 레벨이 s_k인 대응 화소로 매핑해서 얻어진다. 이 식의 변환 (매핑) T(r_k)를 히스토그램 평활화 또는 히스토그램 선형화 변환이라 한다.
영상이 주어지면 히스토그램 평활화 과정은 단순히, 주어진 영상으로부터 직접 추출될 수 있는 정보에 기반해서, 파라미터 규정이 필요 없이 식을 구현하는 것만으로 자동으로 구현된다.
[3.3.2 히스토그램 매칭(지정)]
히스토그램 평활화는 균등한 히스토그램을 갖는 출력 영상을 만드는 변환 함수를 자동으로 결정한다. 자동 개선이 필요할 때는 이 기법의 결과가 예측 가능하고 방법의 구현이 간단하기 때문에, 이것은 좋은 접근법이다.
이 절에서는 히스토그램을 균등하게 만들어서 개선하려는 시도가 최선의 방법이 아닌 응용들도 있다.
때로는 처리된 영상이 갖게 되기를 원하는 히스토그램 모양을 지정할 수 있다면 유익하다. 처리 영상이 지정된 히스토그램을 갖도록 만드는 데 사용되는 방법을 히스토그램 매칭(지정)이라고 부른다.
연속적 밝기 r과 z(연속적 랜덤 변수)로 간주하고, p_r(r)과 p_z(z)가 각각 해당 연속적 확률 밀도 함수라고 하자, 이 표기에서 r과 z는 각각 입력과 출력(처리된) 영상들의 밝기 레벨을 나타낸다. p_r(r)은 주어진 입력 영상으로부터 추절할 수 있으며, p_z(z)는 출력 영상이 갖게 되기를 원하는 지정된 확률 밀도 함수이다.
히스토그램 지정의 원리는 간단하다. 하지만 T(r)과 (변환함수)G^(-1)에 대한 의미 있는 분석적 공식을 찾는 것이 어렵다. 이는 이산 수량을 다룰 때는 현저하게 단순화 된다. 원하는 히스토그램에 대한 근사화만 되면 달성 가능하다.
히스토그램 지정 절차는 다음과 같이 요약할 수 있다.
1. 주어진 영상의 히스토그램 p_r(r)을 계산하고, 이를 사용해서 히스토그램 평활화 변환을 찾아낸다. 결과값 s_k를 [0, L-1] 범위의 정수로 전환한다.
2. q = 0, 1, 2, ..., L-1에 대해 변환 함수 G의 모든 값을 계산한다. p_z(z_i)가 지정된 히스토그램의 값들이다. 이 값들을 모두 [0, L-1] 범위의 정수들로 전환한다.
3. 모든 s_k에 대해, G(z_q)가 s_k에 가장 가깝도록 2단계에서 구한 G의 값을 사용해서 z_q의 값을 찾아내고 z로 이 매핑들을 저장한다. 주어진 s_k를 둘 이상의 z_q 값들이 충족할 때(매핑이 유일하지 않을 때)는 가장 작은 값을 선정한다.
4. 입력 영상을 히스토그램-평활화하고, 그 영상을 모든 평활화된 화소 값 s_k를 단계 3에서 찾아낸 매핑들을 이용해 평활화 영상의 대응 값 z_q로 매핑한다.
히스토그램 지정은 먼저 사용하는 것이 아닌 시행착오 끝에 사용하는 프로세스이다.
[3.3.3 지역적 히스토그램 처리]
히스토그램 처리 방법들은 화소들이 전체 영상의 밝기 분포에 기반한 변환 함수에 의해 수정된다는 면에서 전역적이다. 전반적인 향상에는 적합하지만, 영상의 작은 영역의 디테일을 개선시킬 필요가 있는 경우들이 있다. 이런 영역들의 화소 수는 원하는 지역적 개선을 꼭 보장하지는 않는 전역적 변환의 계산에 대해 무시할 수 있을 정도의 영향을 끼칠 수 있다. 
그 해법은 영상의 각 화소의 이웃의 밝기 분포에 기반해서 변환 함수를 만드는 것이다.
이웃을 정의하고 그 중심을 한 화소씩 이동시키는 것으로 앞선 전역적 히스토그램 처리 기법들이 지역적 개선 목적으로 개조된다. 각 위치에서, 이웃 화소들의 히스토그램이 계산되며, 히스토그램 평활화 또는 지정 변환 함수가 얻어진다.
이 함수가 이웃의 중심 화소의 밝기를 매핑하는데 이용된다. 그 다음, 이웃 영역의 중심이 인접 화소 위치로 이동되고, 위 절차가 반복된다.
이웃의 위치가 한 화소씩 이동하는 동안 이웃의 한 행 또는 한 열만 바뀌기 때문에, 이전 위치에서 얻어진 히스토그램을 각 이동 단계에서 등장하는 새로운 데이터로 갱신하는 것이 가능하다. 이 접근법은 이웃 영역이 한 화소 만큼씩 이동될 때마다 이웃 영역의 모든 화소들의 히스토그램을 반복적으로 계산하는 것에 비해 분명히 유리하다.
계산량을 줄이기 위해 가끔 사용되는 다른 방법은 겹치지 않는 영역들을 이용하는 것인데, 이 방법은 대개 바람직하지 않은 "블록(blocky)"효과를 일으킨다.
[3.3.4 영상 개선을 위해 히스토그램 통계 이용하기]
영상 히스토그램으로부터 직접 얻어진 통계가 영상 개선에 이용될 수 있다. [0, L-1] 범위의 밝기 값을 나타내는 이산 랜덤 변수 r, r_i에 대응하는 정규화된 히스토그램 성분을 p(r_i)라면 p(r_i)는 히스토그램이 얻어진 영상에서 밝기 r_i가 발생하는 확률에 대한 추정으로 볼 수 있다.
영상의 평균 밝기는 영상의 모든 화소값들을 더하고, 그 합을 영상의 화소 수로 나누어 간단하게 구할 수 있다.
개선 목적을 위한 평균과 분산의 두 가지 용도를 고찰하자. 전역 평균과 분산은 전체 영상에 대해 계산되며, 전체적 밝기 및 콘트라스트의 전반적인 조정을 위해 유용하다.
이 파라미터들은 영상의 각 화소를 중심으로 하는 이웃의 특성에 종속되는 지역 평균 및 분산에 근거하는 지역적 개선에서 더 쓸모가 있다.
지역 평균 및 분산을 사용하는 영상 처리의 중요한 면은 영상 모양과 밀접하고 예측 가능한 일치를 보이는 통계적 척도들에 기반한, 간단하면서도 강력한 개선 기법들을 개발할 때 그들이 제공하는 유연성이다.
지역 영역의 크기는 디테일을 보존하고 계산 부담을 가능한 낮게 유지하기 위해 가능한 한 작아야 한다.

[3.4 공간 필터링의 기초]
영상 처리를 위한 공간 필터의 이용에 관한 몇 가지 기본적인 개념
Filter라는 용어는 주파수 도메인 처리에서 가져왔고, Filtering은 특정 주파수 성분들을 통과시키거나 거부하는 것이다. 낮은 주파수를 통과시키면 저역통과 필터라고 한다. 이는 영상을 부드럽게(흐릿하게) 만든다. 공간 필터는 선형, 비선형 필터링에 사용 가능하다.
[3.4.1 공간 필터링의 메커니즘]
필터링은 이웃의 중심의 좌표와 같은 좌표를 가지며 필터링 연산의 결과를 값으로 하는 새로운 화소를 만든다. 필터의 중앙이 입력 영상의 각 화소를 거쳐감에 따라 처리(필터링)된 영상이 생성된다.
만일 영상 화소들에 수행되는 연산이 선형적이면 선형 공간 필터, 아니면 비선형 필터이다.
(선형 공간 필터링 예제, https://whereisend.tistory.com/230?category=849932)
[3.4.2 공간 코릴레이션과 컨볼루션]
코릴레이션은 필터 마스크를 영상 위로 이동시키면서 각 위치에서 S-o-P(곱들의 합, Sum of Products)를 계산하는 것이다.
컨볼루션은 필터가 먼저 180도 회전된다는 것을 제외하고는 메커니즘이 같다.
함수들이 부분적으로 겹치지 않는다는 것은 양쪽을 출분한 개수의 0으로 패딩해서 필터의 각 화소가 모든 화소를 방문할 수 있게 하여 해결할 수 있다. 필터의 크기가 m이라면 전체 공간의 양쪽에 m-1개의 0을 패딩한다.
만약 코릴레이션시킬 때 필터가 하나만 1이고 나머지는 모두 0인 함수라면 필터가 180도 회전되어 복제된 것이 결과가 된다. 이러한 함수를 이산 단위 임펄스라고 부르고, 이산 단위 임펄스와 코릴레이션시키면 임펄스의 위치에 그 함수가 180도 회전되어 나온다.
컨볼루션은 어떤 함수를 단위 임펄스와 컨볼루션시키면, 임펄스 위치에 그 함수가 복제되어 나온다.
컬볼루션을 하려면, 한 함수를 180도 회전시키고 코릴레이션 연산을 수행하면 된다.
코릴레이션은 영상간 일치(유사성)를 찾는 데에도 사용될 수 있다. 필터가 대칭이라면, 코릴레이션과 컨볼루션의 결과는 같다.
공간 필터링을 수행하기 위해 코릴레이션 또는 컨볼루션을 사용할 것인가에 대해서는 선호도의 문제이다. 중요한 것은 주어진 필터링 작업에 사용되는 필터 마스크가 의도된 연산과 일치하는 방식으로 규정되어야 한다는 것이다.
[3.4.3 선형 필터링의 벡터 표현]
선형 필터링에 대한 식(https://whereisend.tistory.com/230?category=849932)
코릴레이션을 사용한다면 위 식을 그대로 쓰면 되고, 컨볼루션을 사용한다면 필터 w를 180도 회전시켜서 사용하면 된다.
[3.4.4 공간 필터 마스크 만들기]
m*n 선형 공간 필터를 만들려면 mn개의 마스크 계수를 정해야 한다. 또한 계수들은 필터의 임무에 의거해서 선정된다. 이때, 선형 필터링으로 할 수 있는 것은 S-o-P를 구현하는 것이다.
만약 영상의 각 화소를 그 중심으로 하는 3*3의 이웃의 평균 밝기로 바꾼다고 하면 위치 (x, y)에서 평균값은 (x, y)를 중심으로 하는 3*3 이웃의 9개의 밝기 값들의 합을 9로 나눈 것이다. 이는 필터의 각 계수가 1/9인 상황과 같다.
즉, 필터의 각 계수가 1/9인 3*3 마스크에 의한 선형 필터링 연산이 원하는 평균화를 구현한다. 이 처럼 마스크를 만든다.
2-D 가우스 함수는 종 모양을 가지며, 표준편차가 종의 "폭"을 제어한다.
비선형 필터를 만들려면, 이웃의 크기와 이웃에 포함되는 영상 화소들에 수행되는 연산(들)을 규정해야 한다.
예를 들어, 비선형 연산인 max 연산은 영상에서 임의의 점 (x, y)를 중심으로 하는 5*5 max 필터의 25개 화소들의 최대 밝기 값을 구하는 연산을 통해 최대 밝기 값을 (x, y)의 화소 값으로 설정한다.
비선현 필터는 선형 필터로 처리할 수 없는 기능들을 수행할 수 있다.

[3.5 스무딩 공간 필터]
스무딩 필터는 블러링과 노이즈 축소에 사용된다.
블러링은 (큰) 객체 추출 전에 영상으로부터 작은 디테일을 제거하거나, 선 또는 곡선의 작은 끊김을 잇는 것과 같은 전처리 작업에 사용된다.
노이즈 축소는 선형 필터에 의한 블러링으로도 가능하고 비선형 필터링으로도 가능하다.
[3.5.1 스무딩 선형 필터]
스무딩 선형 공간 필터의 출력(응답)은 단순히 필터 마스크의 이웃에 포함된 화소들의 평균이다.
이 필터는 평균(화) 또는 저역통과 필터라고도 불린다.
스무딩 필터는 영상의 각 화소의 값을 필터 마스크에 의해 정의되는 이웃에 있는 밝기 레벨들의 평균으로 교체함으로써, 밝기에서의 가파른 이행(sharp transition)을 감소시킨다. 랜덤 노이즈가 일반적으로 가파른 이행으로 구성되기에, 스무딩의 가장 두드러진 응용은 노이즈 축소이다.
그러나 에지도 가파른 밝기 이행의 특징을 가져서, 평균 필터는 에지를 흐리게 하는 경우도 있다.
평균 필터의 주요 용도는 영상의 무의미한 디테일을 축소하는 데 있다. 무의미한이란 필터 마스크의 크기에 비해 작은 화소 영역을 의미한다.
m*n의 마스크는 1/mn의 정규화 상수를 갖는다. 모든 계수가 같은 공간 평균 필터는 상자 필터라고도 불린다.
화소들이 서로 다른 계수들로 곱해짐을 의미하는 가중 평균을 제공하는 마스크는, 어떤 화소들에는 더 많은 중요성을 부여하고, 그 대신에 다른 화소들의 중요성을 희생시킨다.
마스크의 화소 중 큰 값을 가진 화소일 수록 큰 중요성이 부여되고, 해당 화소와의 거리가 멀수록 중요성이 반비례하게 가중된다.
원점으로부터의 거리가 멀수록 계수값을 줄이는 것은 단순히 스무딩 프로세스에서의 블러링을 축수하려는 시도이다. 여기서 모든 계수들의 합이 컴퓨터 구현을 위해 매력적인 특징인 2의 정수의 멱승인 16으로 나눠지는데 이는 필터마스크의 합을 1로 만들어주기 위함이다. 마스크 합이 1보다 크면 영상이 전체적으로 밝아지고, 1보다 작으면 어두워진다.
실제로는 스무딩된 영상들 간의 차이를 분간하기 힘든데, 그 이유는 영상의 각 위치에서 이 마스크들에 의해 커버되는 영역이 매우 작기 때문이다.
일반적으로 블러링은 영상으로부터 작은 객체들을 제거하기 위해 사용된다.
마스크의 크기는 배경과 섞일 상대적 객체의 크기를 정한다.
입력 > 블러링 > 이진화 순으로 상대적으로 큰 객체들을 검출해낼 수 있다.
[3.5.2 순서-통계(비선형) 필터]
순서-통계 필터는, 응답이 필터에 의해 둘러싸인 영상 영역에 담긴 화소들을 정렬하고, 결정된 값으로 중앙 화소의 값을 교체하는 비선형 필터이다. 가장 잘 알려진 필터는 중간 필터로서, 이웃의 밝기 값들의 중간값으로 중앙 화소값을 교체한다.
중간 필터는 소금-후추 노이즈(임펄스 노이즈)에 특히 효과적이고, 선형 스무딩보다 덜 블러링시킨다.
백분위 수 중 50번째를 사용하면 중간값 필터, 100번째를 사용하면 max 필터가 된다. 0번째를 사용하면 min 필터이다.

[3.6 샤프닝 공간 필터]
샤프닝의 주요 목적은 밝기의 이행을 강조하는 것이다. 샤프닝은 미분에 의해 처리될 수 있다.
근본적으로, 미분 연산자의 응답의 세기는 연산자가 적용된 점에서의 영상의 밝기 불연속 정도에 비례한다. 따라서 영상 미분은 엣지 및 다른 불연속들(노이즈 등)은 강조하고, 밝기가 서서히 변하는 영역들은 무시한다.
[3.6.1 기초]
1차 미분은 밝기가 일정한 영역, 불연속(계단 및 비탈 불연속들)의 시작 및 끝 영역들, 밝기 비탈 영역에서의 작용에 영향을 끼친다.
이 유형의 불연속들은 영상의 노이즈 점, 선, 에지 등을 모델링하는 데 사용될 수 있다. 이들 영상 특징들로 진입하거나 빠져나오는 이행 동안의 미분 작용에도 영향을 끼친다.
디지털 함수의 미분은 차이에 의해 정의된다. 1차 미분을 위해 사용하는 정의는 다음과 같다.
1. 일정한 밝기 영역에서는 0이다.
2. 밝기 계단이나 비탈의 시작에서는 0이 아니다.
3. 비탈을 따르는 영역도 0이 아니다.
편미분을 사용한 이유는 두 변수의 영상 함수를 고찰할 때와 똑같은 표기를 사용하기 위해서이다. 즉, 변수가 2개가 되었을 때와 똑같이 표기하기 위함이다.
0점 교차 특성을 엣지를 찾아내는 데 매우 유용하다.
디지털 영상에서의 엣지는 흔히 비탈처럼 생긴 밝기 이행이다. 이때 비탈상에서 1차 미분이 0이 아니기 때문에 영상의 1차 미분은 두꺼운 에지들을 만든다.
반면에 2차 미분은 0에 의해 분리된 한 화소의 두께의 이중 엣지를 만든다. 이로써 1차 미분보다 훨씬 잘 개선한다고 결론짓는다.
이 특성은 영상을 선명하게 만드는 데 이상적이다.
[3.6.2 영상 샤프닝을 위한 2차 미분의 사용-Laplacian]
이 접근법은 2차 미분의 이산 공식을 정의하고, 그 공식에 기반해서 필터 마스크를 만드는 것으로 구성된다.
영상을 회전시킨 후 필터를 적용하는 것과 필터를 영상에 적용한 후 그 결과를 회전시키는 것이 똑같다는 면에서, 등방성 필터는 회전 불변적이다.
가장 간단한 등방성 미분 연산자는 두 변수의 함수(영상)에 대해 정의되는 Laplacian이 있다.
(Laplacian 공식 https://whereisend.tistory.com/231?category=849932)
Laplacian 영상은 밝기 불연속 성분을 돋보이게 하기 때문에 서서히 변하는 레벨은 무시한다. 때문에 어둡고 특징 없는 배경에 회색 엣지 선들 및 다른 분영속들을 갖는 영상을 만든다.
이러한 Laplacian 영상을 원래 영상에 더해서 샤프닝 효과를 보이면서 배경의 특징들을 복구할 수 있다.
Laplacian 필터의 중앙 계수가 음수면 원본 영상과 결합시킬때 더하지 않고 빼야한다.
[3.6.3 언샤프 마스킹과 고주파 증폭 필터링]
언샤프 마스킹은 다음 단계들로 구성된다.
1. 원래 영상을 블러링시킨다.
2. 블러링된 영상을 원래 영상으로부터 뺀다(결과로 얻은 차이를 마스크라고 부른다.)
3. 이 마스크를 원래 영상에 더한다.
가중치 k를 일반성을 위해 더하는데, k=1이면 언샤프 마스킹, k>1이면 고주파 증폭(하이 부스트) 필터링이며, k<1이면 언샤프 마스크의 기여가 덜 강조된다.
언샤프 마스크를 입력 영상에 더하면 강조(샤프닝)된다. 만약 원래 영상에 0값이 있든지, 또는 k의 값이 마스크의 피크들을 원래 영상의 최소값보다 더 큰 레벨로 강조하기에 충분할 정도로 크게 선정된다면, 최종 결과에 음 값의 밝기가 있을 수 있다. 이 음 값들은 엣지 주위의 어두운 후광을 야기한다.
[3.6.4 영상 샤프닝을 위한 1차 미분의 사용-기울기]
1차 미분은 기울기의 크기를 이용해서 구현된다. 좌표 (x, y)에서의 함수의 기울기는 2차원 열 벡터로 정의되는데 이는 (x, y) 위치에서 함수 f의 최대 변화율의 방향을 가리킨다는 기하 특성을 갖는다.
입력 영상의 기울기 벡터의 방향에서의 변화율 값의 (x, y)가 함수의 모든 화소 위치로 바뀔 수 있게 허용되었을 때 생성된 영상을 기울기 영상이라고 부른다.
기울기 벡터의 요소들은 미분들이므로 선형 연산자들이다. 반면에 편미분들은 회전 불변적(등방성)이지 않으나, 기울기 벡터의 크기는 그렇다. 어떤 구현에서는 제곱과 제곱근 연산들을 절대값으로 근사화시키는 것이 계산상 더 적절하다.
기울기를 근사화하기 위해 사용되는 가장 인기있는 마스크는 90도 배수 각도에서 등방성이다.
로버츠 교차(대각선)-기울기 연산자(Roberts cross-gradient operator)라고 불리는 마스크와 소벨 연산자(Sobel operator)는 이러한 개념을 바탕으로 파생된 유명한 필터 2가지이다.
기울기는 결함 검출 작업이나 자동 검사의 전처리 단계로 자주 사용된다.

[3.7 공간 개선 방법 결합하기]
세세한 디테일을 강조하기 위해서는 Laplacian을 사용하고, 중요한 엣지를 개선하기 위해서는 기울기를 사용한다.
Laplacian 영상을 마스킹하기 위해 기울기 영상의 스무딩된 버전이 사용될 것이다.
Laplacian은 2차 미분 연산자이기 때문에 세세한 디테일 개선에 우월하지만, 노이즈가 많은 결과가 나온다. 이 노이즈는 눈에 잘 띄는 경향이 있는 부드러운 영역에서 눈에 거슬린다. 이러한 노이즈를 중간값 필터로 없앨 수도 있지만 그러면 중요한 특징까지 같이 없어질 수도 있어서 사용하지 않는다.
기울기는 현저한 밝기 이행이 있는 영역(비탈, 계단 등)에서 Laplacian보다 더 강한 평균 반응을 보인다. 노이즈와 미세한 디테일에 대해서는 Laplacian보다 반응이 작으며, 평균 필터로 기울기를 스무딩해서 더 낮출 수도 있다.
요점은 기울기를 스무딩하고, 이를 Laplacian 영상으로 곱하는 것이다. 스무딩된 기울기를 마스크 영상으로 보면, 이 곱은 강한 영역에서는 디테일을 보존하면서, 상대적으로 단조로운 영역에서는 노이즈를 줄일 것이다.
이 곱 영상을 원래 영상해 더해서 샤프닝된 영상을 만들면 원래 영상에 비해 디테일의 선명도가 현저히 높아진다.
샤프닝 방법은 영상의 밝기 레벨의 동적 범위에 영향을 미치지는 않는다. 따라서, 밝기 레벨을 조정해야 할 수도 있는데, 어두운 밝기 분포를 갖는 영상에 대해서는 히스토그램 평활화가 잘 작용하지 않는다. 히스토그램 지정이 해법이 될 수 있으나 거듭제곱-법칙 변환이 훨씬 유리하다.

[3.8 밝기 변환과 공간 필터링을 위해 퍼지 기법 사용하기]
[3.8.1 소개]
집합은 객체(요소)들의 집합이며, 집합 이론은 집합에 대한 또는 집한 갑의 연산을 다룬다.
모호한(퍼지) 표현들의 예시로 사람의 나이에 대해 막연하게 젊다고 하는 것을 들 수 있으며, 무수한 값들을 갖는 멤버쉽 함수들을 퍼지 논리의 근간으로 생각할 수 있다.
이를 이용해서 생성되는 집합을 퍼지 집합이라한다.
[3.8.2 퍼지 집합 이론의 원리]
퍼지 집합은 막연한 정보를 다루기 위한 형식을 제공한다.
요소(객체)들의 집합을 Z, 이의 요소를 z라 할때, 이 집합을 논의의 영역이라고 한다. Z의 퍼지 집합 A는 [0, 1] 구간의 실수를 Z의 각 요소와 결합시키는 멤버쉽 함수에 의해 특징지어진다.
z에서의 멤버쉽 함수값은 A에 있는 z의 멤버쉽등급을 표현한다. 멤버쉽 함수 값이 1에 가까울수록 A에서의 z의 멤버쉽 등급이 높으며 0에 가까울수록 반대이다.
멤버쉽 함수 값이 1인 모든 z는 그 집합의 완벽한 멤버이며, 0인 모든 z는 그 집합의 멤버가 아니며, 0과 1 사이인 모든 z는 그 집합에 대해 부분적 멤버쉽을 갖는다고 한다.
A를 예를 들어 (22, 0.8)은 22가 집한에서 0.8의 멤버쉽 값을 갖는 걸 의미한다.
멤버쉽 함수 값이 0 또는 1로만 구성되면 보통의 크리스프 집합의 특성 함수가 된다. 즉, 보통 집합(0 OR 1)은 퍼지 집합의 특수한 경우이다.
퍼지 집합을 포함하는 몇 가지 정의는 다음과 같다.
공집합: 퍼지 집합은 그 멤버쉽 함수가 Z에서 0인 경우에 한하여 원소를 포함하지 않는다.
상등: 두 퍼지 집합 A, B는 모든 z에 대해 각 멤버쉽 함수 값이 모두 동일한 경우 상등이며 A=B라 쓴다.
보집합: 퍼지 집합 A의 보(NOT)는 NOT(A)로 표기(혹은 A 바)그 멤버쉽 함수는 모든 z에 대해 1-멤버쉽 함수(z)의 값을 갖는다.
부분집합: 퍼지 집합 A의 모든 z에 대해 퍼지 집합 B의 멤버쉽 함수 값보다 작거나 같으면 B의 부분집합이다.
합집합: 두 퍼지 집합 A, B의 합(OR)은 모든 z에 대해 멤버쉽 함수가 두 값 중 더 큰 걸(max) 택한다.
교집합: 두 퍼지 집합 A, B의 합(OR)은 모든 z에 대해 멤버쉽 함수가 두 값 중 더 작은 걸(min) 택한다.
[3.8.3 퍼지 집합 이용하기]
예를 들어 어떤 과일이 주어지고 미숙, 반숙, 성숙으로 구분해야하는데 컬러를 이용한다. 여기서 안 익으면 녹색, 반쯤 익으면 황색, 다 익으면 적색이라면 컬러가 언어 변수, 특정 컬러가 언어 값(linguistic value)가 된다. 언어 값은 [0, 1] 구간으로 매핑하기 위한 멤버쉽 함수를 사용해서 퍼지화된다.
퍼지 IF-THEN 규칙들의 형태로 형식화될 수 있다.
R_1 : IF 컬러가 녹색, THEN 과일은 미숙
				OR
R_2 : IF 컬러가 황색, THEN 과일은 반숙
				OR
R_3 : IF 컬러가 적색, THEN 과일은 성숙
다음 단계로 퍼지 시스템의 출력을 만들기 위해 입력(컬러)과 IF-THEN 규칙들에 의해 표현되는 지식 베이스를 이용하는 방법을 찾는다. 이 과정을 함의 또는 추론이라고 한다.
함의 과정이 적용되기 전에 단일 값을 산출하기 위해서 각 규칙의 전항이 처리되어야 한다. 전항의 여러 성분들은 AND와 OR에 의해 연결된다. 이는 min과 max 연산을 수행하는 것을 의미한다.
여기서 입력의 독립 변수는 컬러지만, 이와 달리 출력의 독립 변수는 숙성도가 된다.
전체적인 응답을 얻기 위해서 개별적 응답들을 집산(aggregate)한다. 이 예시에서 세 규칙이 OR로 결합되므로 집산된 퍼지 출력은 개별 응답들의 합집합이란 것을 알 수있다 이는 max 연산으로 이어진다.
퍼지 집합의 마지막은 비퍼지화를 통해 크리스프 출력을 얻는 것이다. 비퍼지화의 대표적인 방법은 무게중심을 계산하는 것이다.
[3.8.4 밝기 변환을 위한 퍼지 집합 이용]
밝기 변환의 주요 응용 분야 중 하나인 일반적인 콘트라스트 개선 문제를 고찰하면, 그레이 스케일 영상의 콘트라스트를 개선하는 과정을 다음과 같은 규칙들로 규정할 수 있다.
IF a pixel is dark, THEN make it darker.
IF a pixel is gray, THEN make it gray.
IF a pixel is bright, THEN make it brighter.
출력과 관현해서 darker는 어두운 밝기 값의 정도(100% 흑색), brighter는 밝은 명암의 정도(100% 백색), gray는 그레이 스케일의 중간 밝기 정도로 생각할 수 있다. 여기서 "정도"는 특정 밝기의 양이다.
예를 들어 80% 흑색은 매우 어두운 회색이다. 출력 멤버쉽 함수들은 일정한 밝기들로 해석된다. 즉, 싱글톤들이다.
퍼지 영상 처리는 계산량이 많다. 따라서 싱글톤들을 사용하면 계산 요구량이 현저히 줄어든다. 이는 처리 속도가 중요한 요건의 응용에서 중요하다.
밝기가 좁은 그레이 스케일 범위의 영상에 히스토그램 평활화를 하게 되면 전체 그레이 스케일을 확장하게 되어 콘트라스트가 증가하나 영상에 "노출 과다" 현상을 일으키는 최소 및 최대 부근의 밝기들을 갖게 한다.
이는 디테일이 사라지는 것을 의미한다. 이를 출력 싱글톤을 0(흑색), 127(중간 회색), 255(백색)으로 선정하여 규칙-기반 콘트라스트 수정 방법을 사용하면 히스토그램 평활화보다 색조부분에서 상당히 개선된다. 뿐만 아니라 디테일 수준도 좋아진다.
이 개선의 이유는 평활화 된 히스토그램과 달리 규칙-기반 콘트라스트 기법의 히스토그램은 원래 영상의 히스토그램의 기본적 특성을 유지하나, 어두운 레벨들이 왼쪽으로 이동됨으로써, 이 레벨들을 더 어둡게 만들었다. 밝은 레벨들에 대해서는 그 반대로 작용되었고 중간 회색들은 약간만 벌어졌다.
균형 잡힌 영상의 히스토그램이 필요할 때 퍼지 기법을 사용한다. 이를 통해 얻은 이상적 히스토그램을 매핑을 통해, 히스토그램 지정 같은 더 빠른 기법들로 비슷한 결과를 얻을 수 있다.
[3.8.5 공간 필터링을 위한 퍼지 집합 이용]
공간 필터링에 퍼지 집합을 적용할 때, 기본적 접근법은 필터가 검출하기로 되어 있는 것의 본질을 "캡쳐"하는 이웃 속성들을 정의하는 것이다. 예를 들어 영역 간의 경계를 검출하는 문제가 있다.