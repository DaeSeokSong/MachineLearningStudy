[기본 데이터 타입]
	C++ 프리미티브 타입(int, float 등)에서 직접 구성한 데이터 타입
	단순 벡터와 행렬뿐만 아니라 포인트, 직사각형, 사이즈 등과 같은 간단한 기하학적 개념도 포함된다.

	* Vec<> 클래스 템플릿
		가장 간단한 OpenCV 기본 데이터 타입

		프리미티브 타입의 컨테이너 클래스로, 고정 벡터 클래스라고도 불린다.
		STL 클래스와 차이점은 컴파일 시간에 차원을 알 수 있는 작은(요소가 몇 개 이상이라면 잘못된 클래스를 사용하고 있을 가능성이 크다.) 벡터를 대상으로 한다는 점이다. 이 점에서 매우 효율적이게 된다.

		Mat 클래스가 대형 배열을 다루는 올바른 방법이라면 소형 배열을 위한 건 Vec이다.

		일반적인 별칭으로 Vec{2, 3, 4, 6}{b, w(unsigned short), s, i, f, d}와 같은 형태의 표현은 4개의 차원의 크기와 6가지 데이터 타입의 모든 조합에 대해 유효하다.

		고정 행렬 클래스를 상속한다. 실제로 Matx에 대한 편리한 기능일 뿐이다. Matx에서 열이 수가 1이면 Vec이라 한다.

		※ 지원하는 연산
			기본 생성자, 복사 생성자, 값 생성자, 멤버 전급, 벡터 외적

	* Matx<> 클래스 템플릿
		고정 행렬 클래스, 고정 벡터 클래스(Vec)와 마찬가지로 대형 배열에 사용하기 위한 것이 아니라 어떤 특정 소형 행렬 연산을 처리하도록 설계됐다.

		행렬 객체를 담기 위해 설계되었으며 보통 Matx{1, 2, 3, 4, 6}{1, 2, 3, 4, 6}{f, d} 형태의 별칭으로 사용된다

		고정 행렬 클래스의 차원 크기를 컴파일 시간에 알 수 있어야 한다는 걸 꼭 알아야 한다.
		이 덕분에 동적 메모리 할당 작업을 없애므로 작업을 효율적을 만들어준다.

		데이터에 대한 모든 메모리가 스택에 할당돼 메모리 할당과 헤제 속도가 빠르다.
		2x2나 3x3같은 소형 행렬 연산에 어울리며 이미지가 거대한 포인트 목록과 같은 대형 데이터 배열의 경우에는 Mat 클래스가 더 어울린다.

		※ 지원하는 연산
			기본 생성자, 복사 생성자, 값 생성자, 동일 원소 행렬 반환, 0 행렬 반환, 1 행렬 반환, 단위행렬 생성, 주어진 대각선 요소를 가지는 행렬 생성, 균등 분포된 요소로 행렬 생성, 정규 분포된 요소로 행렬 생성, 멤버 접근, 행렬 대수, 싱글톤 대수, 비교, 내적(dot), 배정밀도 내석, 행렬 크기 변환, 캐스팅 연산자, (i, j)위치의 2x2부분 추출, i행 추출 j열 추출, 행렬 대각선 요수 추출, 행렬 전치 계산, 역행렬 계산, 선형 시스템 풀이, 요소별 곱셈(mul)

		Matx 클래스의 멤버 함수는 상당수가 정적이기 때문에, 특정 객체의 멤버가 아닌 클래스의 멤버로 직접 함수에 접근할 수 있다.
		Ex. Matx33f = Matx<> 템플릿을 3x3크리고 인스턴스화한 타입의 별칭

	* 포인트 클래스
		프리미티브 타입의 2개 또는 3개의 값을 저장한다.
		자체 템플릿에서 파생하기에 고정 베벡터 클래스의 직접적인 하위 클래스는 아니지만 상호 캐스팅할 수 있다.

		고정 벡터 클래스와의 큰 차이점은 벡터 인덱스(Ex. vec[1], vec[0])가 아닌 명명된 변수로 구성 멤버에 접근한다는 것(Ex. point.x, point.y)

		Vec처럼 템플릿을 인스턴스화한 타입에 대한 별칭으로 보통 사용한다.
		Ex. Point2i, Point2f, Point3i 등

		간단하고 오버헤드가 거의 없다. 많은 연산 작업을 정의하지는 않지만 좀 더 일반화된 타입으로 캐스팅할 수 있다. (Ex. 고정 벡터/행렬 클래스)

		별칭의 마지막 문자는 포인트값을 나타낼 프리미티브 타입을 나타낸다.
			* b, 부호 없는 문자(unsigned char)
			* i, 32비트 정수(int)
			* f, 32비트 부동 소수점 수(float)
			* d, 64비트 부동 소수점 수(double)

		연산 작업시 Vec 클래스로 암시적 캐스팅을 지원하여 오버로딩된 벡터 및 싱글톤(타입에 상관없이 벡터가 배열로 구성되는 단일 객체) 대수 연산자와 비교 연산자 모두를 포함

		※ 지원하는 연산
			기본 생성자, 복사 생성자, 값 생성자, Vec 클래스로 캐스팅, 멤버 접근, 내적, 배정밀도 내적, 외적, 포인트 p가 직사각형 r에 있는지 질의

	* Scalar 클래스
		4차원 포인트, Scalar는 4차원 배정밀도 벡터를 나타낸다.

		포인트 클래스와 마찬가지로 임의 타입의 4-요소 벡터를 생성할 수 있는 템플릿과 관련있지만 구체적으로 배정밀도 타입의 4-요소 벡터를 나타내는 데 사용하는 별칭이다.

		Vec처럼 인덱스로 접근하여 사용한다. Vec 클래스 템플릿을 인스턴스화한 타입에서 직접 파생되기에

		Scalar라는 별칭은 모든 멤버가 배정밀도 부동 소수점 수를 갖게 해당 인스턴스화한 타입을 반환

		※ 지원하는 연산
			기본 생성자, 복사 생성자, 값 생성자, 요소별 곱셈, 켤레(conj), 실수 테스트(isReal)

		Vec 클래스의 모든 속성을 상속한다.

	* Size, Rect 클래스
		Size는 주로 x, y 대신에 width와 height라는 데이터 멤버가 있다.
		Rect는 이 네 가지 데이터 멤버를 모두 가진다.

		Size에서 width와 height를 부동 소수점 값으로 다룰 경우에는 Size2f라는 별칭을 사용하면 된다.
		Size는 포인트 클래스와 상호 캐스팅할 수 있다. 포인트는 x와 y를 Size는 width와 height를 가짐

		별칭은 Size(정수 사이즈), Size2i(정수 사이즈), Size2f(32비트 부동 소주점 사이즈)

		※ 지원하는 연산(Size)
			기본 생성자, 복사 생서자, 값 생성자, 멤버 접근, 면적 계산

		직사각형 클래스는 포인트 또는 사이즈 클래스가 제공하는 연산자를 상속하지 않는다.

		※ 지원하는 연산(Rect)
			기본 생성자, 복사 생성자, 값 생성자, 원점과 사이즈로부터 새성, 두 코너로부터 생성, 멤버 접근, 면적 계산, 왼쪽 위 코너 추출, 오른쪽 아래 코너 추출, 포인트 p가 직사각형 r 안에 있는지 테스트

		※ 오버로딩된 연산(Rect)
			두 직사각형 간 교차 직사각형 계산, 두 직사각형을 포함하는 최소영역 직사각형 계산, 직사각형 r을 x만큼 이동, 직사각형 r을 사이즈 s만큼 확대, 두 직사각형간 상등/부등 비교

		마찬가지로 축 정렬되지 않은 직사각형을 나타내려면 RotatedRect 클래스를 사용 하면 된다.
		탬플릿이 아닌 OpenCV C++ 인터페이스이다.

		Point2f 타입의 center, Size2f 타입의 size, center로부터 직사각형의 회전값을 나타내는 float 타입의 angle 데이터 멤버를 가진다.

		Rect와 RotatedRect의 중요한 차이점은 Rect는 왼쪽 위 코너를 기준으로 배치, RotatedRect는 중심을 기준으로 공간에 배치한다는 것이다.

		※ 지원하는 연산(RotatedRect)
			기본 생성자, 복사 생성자, 2개의 코너로부터 생성, 값 생성자(포인트, 사이즈, 화전각), 멤버 접근, 4개의 코너 반환

	* 복소수 클래스
		STL의 복소수 클래스 complex<>와 호환 가능하며 상호간 캐스팅이 가능하다.

		STL의 complex에서는 real()과 imag()로 실수와 허수 부에 접근하지만 OpenCV의 복소수 클래스에서는 public 멤머 변수인 re와 im으로 직접 접근한다. 

		※ 지원하는 연산
			기본 생성자, 복사 생성자, 값 생성자, 변환 생성자, 멤버 접근, 복소 켤레

[도우미 객체 타입]
	가비지 컬렉팅 포인터 클래스와 슬라이싱에 사용하는 범위 객체 종료 조건과 같은 좀 더 추상적인 개념

	* TermCriteria 클래스
		한정된 반복수 지정이나 근접시 종료와 같은 오류 허용치 파라미터 같은 정지 기준 중 하나 또는 둘 모두를 캡슐화 한다.

		type, maxCount, epsilon 3개의 public 멤머 변수를 가진다 직접 설정하거나 생성자에 의해 값을 지정하는 형식으로 사용(주로 생성자로 초기화)

		type은 종료기준이며 TermCriteria::Count 또는 TermCriteria::EPS로 설정한다. 또는 | 연산을 이용해 둘 다 지정할 수도 있다.

		TermCriteria::Count는 TermCriteria::MAX_ITER와 같은 의미이고 이는 maxCount 이후에 알고리즘을 종료시킨다.

		TermCriteria::EPS는 어떤 측정치가 epsilon 이하로 떨어졌을 때 종료할 수 있게 알고리즘에 알린다.

	* Range 클래스
		연속적인 정수의 시퀀스를 지정하는 데 사용

		start와 end라는 public 멤버 변수를 가진다 이는 생성자로 값을 설정하고 범위는 시작값 <= ~ < 종료값이다.

		size()를 사용하면 범위 내 요소의 수를 알 수 있다.
		empty()를 사용하면 범위에 요소가 없는지 테스트한다.
		all()을 사용하면 객체가 사용할 수 있는 범위를 나타낼 필요가 있는 곳이라면 사용가능하다.

	* Ptr 클래스 템플릿 ★★★
		* 스마트 포인터
			어떤 객체에 대한 참조를 생성한 후에 그 객체를 간접적으로 다룰 수 있다.
			스마트 포인터 객체에 대한 참조를 더 만들면 내부 참조 카운터가 증가한다.
			참조가 범위를 벗어나면 스마트 포인터에 대한 내부 참조 카운터가 감소한다.
			모든 참조(인스턴스)가 사라지면 스마트 포인터가 내부적으로 저장하고 있던 객체는 자동으로 할당 해제된다.

			스레드로부터 안전하게 구현됐으며 OpenCV에서 다른 참조 계산을 수행하는 객체들도 모두 스레드에 안전하다.

			* 사용 방법
				1. 래핑하려는 클래스 객체에 대한 포인터 템플릿의 인스턴스를 정의
				>> Ptr<Matx33f> p(new Matx33f) 또는 Ptr<Matx33f> p = makePtr<Matx33f>
				*	보통의 포인터에 적용할 수 있는 *와 -> 연산자를 operator*() 및 operater->()
					연산자 오버로딩을 통해 지원한다.

				2. 동일한 타입의 다른 스마트 포인터 생성
				>> Ptr<Matx33f> q(new Matx33f) 또는 Ptr<Matx33f> q = makePtr<Matx33f>
				*	두 포인터가 가리키는 실제 Matx33f 객체는 하나밖에 없다. 각자의 포인터들은 서로의 존재를 알고있어서 모든 포인터가 사라지면 원래 행렬(Matx)인 지정 객체를 메모리 할당 해제한다. (Ex. 건물에서 마지막에 나가는 사람이 불 끄기)

				3. 이후 초기화된 스마트 포인터는 보통의 포인터와 같은 방법으로 사용할 수 있다.

				Ex. Ptr<IplImage> img_p = cvLoadImage("~");

			* 멤버 함수
				* addref(), 내부 참조 카운터 증가
				* release(), 내부 참조 카운터 감소
				* empty(), 할당 해제된 객체를 가리키는지 확인하는데(release()를 한 번 이상 호출한 경우) 또는 스마트 포인터 객체 내부 포인터가 어떤 이유로 인해 NULL 값을 가질 수도 있으니 확인하는데(NULL 반환하는 함수 사용할 때) 사용
				* delete_obj(), 내부 참조 카운터가 0이 되면 자동 호출되며 기본적으로 delete obj 문장을 수행한다. 스마트 포인터 객체가 소멸할 때 특성 리소스 정리 작업을 수행해야할 때 사용한다.

	* Exception 클래스
		code, err, func, file, line 멤버 변수가 있으며, 순서대로 숫자 오류 코드, 예외를 생성한 오류의 성질을 나타내는 문자열, 오류가 발생한 함수 이름, 오류가 발생한 파일, 해당 파일에서 오류가 발생한 행 번호를 나타낸다. 모두 cv::String 타입의 문자열이다.

		* 내장 메크로
			* CV_Error(errorcode, description), 고정된 오류 설명과 함께 예외 발생
			* CV_Error_(errorcode, printf_fmt_str, [printf-args]), 고정된 오류 설명을 printf 함수에서 사용하는 포맷 문자열과 전달인자로 대체한다는 점을 제외하고는 같다.
			* CV_Assert(condition) / CV_DbgAssert(condition), 조건을 테스트해서 만족하지 않으면 예외를 발생시킨다. 후자는 디버그 빌드에서만 작동

	* DataType<> 템플릿
		opencv 함수가 특정 데이터 타입의 개념 정보를 확인해야 할 때 DataType<>타입 객체를 생성해서 처리한다. 이 자체는 템플릿이므로 전달된 실제 객체는 이 템플릿을 특수화한 타입이다. C++에서 트레잇이라고 부르는 기법의 한 에이다.

		* enum 상수
			* generic_type, 정의된 모든 타입 중 가장 일반적인 값
			* depth, opencv가 사용하는 데이터 타입 식별자이다. Ex. DataDepth<float>::value는 CV_23F라는 상수로 해석된다.
			* channels, float가 숫자 하나라면 channels 상수 값은 1이다.
			* fmt, 해당 포맷의 단일 문자 표현 값 Ex. DataDepth<float>::fmt는 f로 해석된다.
			* type, depth와 비슷하지만 channels값까지 포함한다. Ex. CV_MAKETYPE(CV_32F, 1)은 CV_32FC1으로 해석된다.

		* 멤버 변수
			* value_type, 설명하고 있는 대상
			* work_type, DataType<>에서 구성된 변수의 종류
			* channel_type, 대중 채널 객체로 나타내는 방법을 알려준다.
			* vec_type, 해당 데이터 타입 템플릿 안 클래스를 Vec클래스로 나타내는 방법을 알려준다.

	* InputArray / OutputArray 클래스
		두 클래스의 주된 차이는 전자를 const, 읽기 전용으로 가정한다는 점이다.
		OpenCV 라이브러리 함 수를 살펴볼 때 이 타입의 매개변수가 있다면 그건 Scalar 같은 타입은 물론이고 어떤한 배열의 형태더라도 사용할 수 있다는 걸 의미한다.

		InputArray를 반환하는 특수 함수 noArray()가 있다. 이로 반환한 객체는 특정 입력 부분이 사용되지 않는다는 것을 나타내기 위해, InputArray 인자를 필요로 하는 모든 입력에 전달이 가능

	* 유틸리티 함수
		일반적으로 사용하는 수학과 기타 연산 작업을 더욱 효율적으로 처리할 수 있는 특수 함수

		* 유틸리티 및 시스템 함수
			* alignPtr(정렬되지 않은 포인터, 정렬 크기(2의 거듭제곱)), 주어진 바이트 수에 포인터 정렬
			* alignSize(정렬할 버퍼 크기, 정렬 크기(2의 거듭제곱)), 버퍼 크기를 주어진 바이트 수에 정렬
			* allocate(할당할 요소 개수), C 스타일 객체 배열 할당, new 키워드르 사용해 배열을 할당하는 방식과 비슷하게 동작
			* deallocate(할당 해제할 버퍼 포인터, 버퍼에 있는 요소 개수), C 스타일의 객체 배열 할당 해제, delete 키워드로 배열 해제하는 방식과 유사하게 동작
			* fastAtan2(y(32비트 float), x(32비트 float)), 벡터의 2차원 각도를 도 단위로 계산
			* cvCeil(x(32비트 float)), float 타입 숫자를 x를 x보다 작지 않은 가장 작은 정수로 올림
			* cubeRoot(x(32비트 float)), 세제곱근 계산
			* CV_Assert(조건(Ex. x != 0)), 주어진 조건이 true가 아니면 예외 발생
			* CV_Error(ecode(에러코드), estring(고정 문자열)), 고정된 문자열을 이용해 Exception 객체 생성, 예외 발생
			* CV_Error_(ecode(에러코드), fmt, ...), 포맷된 문자열을 이용해 Exception 객체 생성, 예외 발생
			* error(const Exception(발생시킬 예외)), 해당 오류 시 예외 발생, 주로 CV_Error()와 CV_Error_() 매크로를 사용해 간접적으로 호출된다.
			* fastFree(void*(할당 해제할 버퍼 포인터)), fastMalloc으로 할당한 버퍼를 해제한다
			* fastMalloc(size_t(할당할 버퍼의 크기)), 정렬된 메모리 버퍼 할당
			* cvFloor(x(32비트 float)), float 타입의 숫자 x를 x보다 크지 않은 정수로 내림
			* format(const char*(포맷 지정용 문자열)), sprintf 스타일의 포매팅을 사용해 STL 문자열 생성, 본질적으로 표준 라이브러리의 sprintf()와 동일하다.
			* getCPUTickCount(void), 내부 CPU 타이머에서 틱 카운트 가져오기, 한 스레드에서 연속 호출해도 반환값에 차이가 있을 수도 있다. 따라서 타이밍 측정을 위해서는 getTickCount()를 사용하는게 좋다.
			* getNumThreads(void), opencv가 현재 사용하고 있는 스레드 수 세기
			* getOptimalDFTSize(int(n보다 같거나 큰)), DFT()에 전달할 배열의 가장 적합한 크기 계산
			* getThreadNum(void), 현재 스레드의 인덱스
			* getTickCount(void), 시스템에서 틱 카운트 가져오기 아키텍처와 운영체제에 따라 틱 카운트 비율이 다르지만 틱당 시간을 이용해 계산할 수 있다.
			* getTickFrequency(void), 초당 틱 수 얻기
			* cvIsInf(double), 부동 소수점 숫자 x가 무한대인지 확인
			* cvIsNaN(double), 부동 소수점 숫자 x가 숫자가 아닌지(NaN 인지) 확인
			* cvRound(double), float 타입 숫자 x를 가장 가까운 정수로 반올림
			* setNumThreads(int), opencv가 사용하는 스레드 수 설정
			* setUseOptimized(bool(false면 비활성화)), SSE2 등과 같은 최적화된 코드 사용을 활성화 or 비활성화
			* useOptimized(void), 최적화된 코드 사용 활성화 상태 확인

[대형 배열 타입]
	기본 목적은 C++ 프리미티브 타입 또는 주로 OpenCV 기본 데이터 타입 객체의 배열 또는 집합체를 나타내는 것이다. 이 타입의 핵심적인 예는 읨의의 기본 요소를 포함하는 임의의 차원 배열을 나타내는 데 사용하는 Mat 클래스이다.
	이 외에도 비밀집 데이터에 더 적합한 희소 행렬 SparasMat 클래스 같은 타입을 포함

* OpenCV는 C++ STL도 적극 활용, 특히 STL 벡터 클래스 탬플릿